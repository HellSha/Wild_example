function DependencyHierarchy(rootModel) {

    var HanaObjectTypes = $.import("sap.hana.testtools.mockstar", "hanaObjectTypes").HanaObjectTypes;

    this.rootModel = rootModel;

    function updateCDSEntitiesRecursive(hanaObject, dependencySubstitutions) {
        hanaObject.getFileDependencies().forEach(function(dependency) {
            updateCDSEntitiesRecursive(dependency, dependencySubstitutions);
        });

        if (hanaObject.type.isOfType(HanaObjectTypes.HDBDD)) {
            dependencySubstitutions.getMatchingRulesForCDSFile(hanaObject).forEach(function(substitutionRule) {
                hanaObject.addEntity(substitutionRule.original.name, HanaObjectTypes.HDBDD, substitutionRule.substitute.schema, substitutionRule.substitute.name, substitutionRule.original.schema);
            });
        }
    }

    function removeElementsNotDependingOnElementsToBeSubstituted(hanaObject, dependencySubstitutions) {
        hanaObject.getFileDependencies().forEach(function(dependency) {
            removeElementsNotDependingOnElementsToBeSubstituted(dependency, dependencySubstitutions);
        });

        hanaObject.removeFileDependenciesMarkedForDeletion();

        if (dependencySubstitutions.hasSubstitutionRuleFor(hanaObject)) {
            hanaObject.removeAllFileDependencies();
        } else if (!hanaObject.hasFileDependencies()) {
            hanaObject.markForDeletion();
        }
    }

    function assignFinalNameAndTypeIfNotDoneAlready(hanaObject, dependencySubstitutions, targetPackage, truncOption) {
        if (!hanaObject.isRelocated()) {
            var substitutionRule = dependencySubstitutions.findSubstitutionRule(hanaObject);
            if (substitutionRule) {
                var substitute = substitutionRule.substitute;
                var authoringSchema = substitutionRule.original.schema;
                hanaObject.replaceByTable(substitute.schema, substitute.name, authoringSchema);
            } else if (!hanaObject.isTable()) {
                hanaObject.moveToUserPackageAndSchema(targetPackage, truncOption);
            }
        }
    }

    function assignFinalNameAndTypeRecursive(hanaObject, dependencySubstitutions, targetPackage, truncOption) {
        hanaObject.getFileDependencies().forEach(function(dependency) {
            assignFinalNameAndTypeRecursive(dependency, dependencySubstitutions, targetPackage, truncOption);
        });

        assignFinalNameAndTypeIfNotDoneAlready(hanaObject, dependencySubstitutions, targetPackage, truncOption);
    }

    function adaptDependenciesInContent(hanaObject, substitutorFactory) {
        var substitutor = substitutorFactory.getMatchingSubstitutor(hanaObject);
        substitutor.execute(hanaObject);
        hanaObject.getFileDependencies().forEach(function(dependency) {
            adaptDependenciesInContent(dependency, substitutorFactory);
        });
    }

    function readCDataRecursive(hanaObject, repository) {
        // TODO: does HanaObjectTypes.HDBDD have to be excluded?
        if (!hanaObject.isTable()) {
            hanaObject.cdata = repository.readCData(hanaObject.getName());
            hanaObject.getFileDependencies().forEach(function(dependency) {
                readCDataRecursive(dependency, repository);
            });
        }
    }

    this.updateEntitiesToBeSubstituted = function(dependencySubstitutions) {
        updateCDSEntitiesRecursive(rootModel, dependencySubstitutions);
    };

    this.removeElementsThatCanRemainUnchanged = function(dependencySubstitutions) {
        removeElementsNotDependingOnElementsToBeSubstituted(rootModel, dependencySubstitutions);
    };

    this.readCData = function(repository) {
        readCDataRecursive(rootModel, repository);
    };

    this.assignFinalNames = function(dependencySubstitutions, targetPackage, truncOption) {
        assignFinalNameAndTypeRecursive(rootModel, dependencySubstitutions, targetPackage, truncOption);
    };

    this.adaptDependenciesInContent = function(substitutorFactory) {
        adaptDependenciesInContent(rootModel, substitutorFactory);
    };

}