/**
 * Created on 01.04.2015.
 */
/**
 * See {@link module:mockstarEnvironment~define mockstarEnvironment.define} function or
 * {@link module:mockstarEnvironment~defineAndCreate mockstarEnvironment.defineAndCreate} to create a dedicated MockstarEnvironment Object.
 *
 * @module mockstarEnvironment
 * @since 1.9.2
 */

var mockstar = require('./apiFacade.js')
var TruncOptions = require('./truncOptions.js')
var SqlExecutor = require('../util/sqlExecutor.js')
var TableUtils = require('../util/tableUtils.js')
var errorLib = require('../error.js')
var mJasmine = require('../jasmine.js')


var define,
    defineAndCreate


var useSchema = false
//var userSchema = $.session.getUsername().toUpperCase();

/* samir
 replace all jasmine.dbConnection through this connection
 */
//var connection = $.db.getConnection()
var connection = mJasmine.dbConnection;

var DependencyType = {
    TABLE : "table",
    VIEW : "view",
    PROCEDURE : "procedure"
};


    //var executorLib = $.import("sap.hana.testtools.unit.util", "sqlExecutor");
    //var utils = $.import("sap.hana.testtools.unit.util", "tableUtils");

    //var errorLib = $.import("sap.hana.testtools.unit.util.internal", "error");

    function getAllDependencySubstitutions(mockstarEnvironment) {
        return Object.getOwnPropertyNames(mockstarEnvironment.dependencySubstitution);
    }

    function findDependencySubstitutionFor(schema, name, type) {
        var existingId = "";
        var me = this;
        getAllDependencySubstitutions(me).forEach(function(id) {
            var dependencySubstitution = me.dependencySubstitution[id];
            if (dependencySubstitution.schema === schema && dependencySubstitution.name === name && dependencySubstitution.type === type) {
                existingId = id;
            }
        });
        return existingId;
    }

    function addDependencySubstitution(id, substitution, type, testDoubleType) {
        if (this.dependencySubstitution[id]) {
            throw new errorLib.UsageError("A dependency substitution with id '" + id + "' already exists");
        }
        var fallbackSchema = null;
        var dependencySubstitution = null;
        if (type === DependencyType.VIEW) {
            fallbackSchema = "_SYS_BIC";
        }
        if (typeof substitution === "string") {
            dependencySubstitution = {
                name : substitution,
                schema : this.schema || fallbackSchema,
                type : type,
                testDoubleType : testDoubleType
            };
        } else if (typeof substitution === "object" && substitution !== null) {
            dependencySubstitution = {
                name : substitution.name,
                schema : substitution.schema || this.schema || fallbackSchema,
                type : type,
                testDouble : substitution.testTable || substitution.testProcedure,
                testDoubleType : testDoubleType,
                data : substitution.data,
                csvFile : substitution.csvFile
            };

            if (substitution.data && substitution.csvFile) {
                throw new errorLib.UsageError("Ambiguous data definition found for test table '" + id + "': 'data' and 'csvFile' given");
            } else if (substitution.data) {
                this.dataDefinitions.push(id);
            } else if (substitution.csvFile) {
                this.csvFileUpload.push(id);
            }
        } else {
            throw new errorLib.UsageError("Invalid definition of dependency substitution");
        }
        var id2 = findDependencySubstitutionFor.call(this, dependencySubstitution.schema, dependencySubstitution.name, type);
        if (id2) {
            throw new errorLib.UsageError("The dependency substitution '" + id + "' has already been defined (id '" + id2 + "')");
        }

        this.dependencySubstitution[id] = dependencySubstitution;
    }

    function addDependencySubstitutions(substitutions, type, testDoubleType) {
        var id = "";
        for (id in substitutions) {
            if (substitutions.hasOwnProperty(id)) {
                addDependencySubstitution.call(this, id, substitutions[id], type, testDoubleType);
            }
        }
    }

    /**
     * Returns the dependency substitution that was defined for an 'id' and which should fulfill some criteria.
     *
     * @param {String}
     *            id - identifier of the view/table to be substituted
     * @param {Object}
     *            criteria
     * @param {String}
     *            [criteria.type] - the type of the original dependency, that should be substituted
     * @param {String}
     *            [criteria.testDoubleType] - the type of the dependency substitution
     *
     * @returns {Object} dependency substitution
     * @inner
     * @private
     * @see {@link module:mockstarEnvironment~defineAndCreate defineAndCreate}
     * @throws an
     *             error if one of the criteria was not fulfilled
     */
    function getDependencySubstitution(id, criteria) {
        var dependencySubstitution = this.dependencySubstitution[id];
        if (!dependencySubstitution) {
            throw new errorLib.UsageError("No dependency substitution defined for id '" + id + "'");
        }
        if (criteria && criteria.type && criteria.type !== dependencySubstitution.type) {
            // TODO test
            throw new errorLib.UsageError("The original type of the dependency substitution with id '" + id + "' is not '" + criteria.type + "'");
        }

        if (criteria && criteria.testDoubleType && criteria.testDoubleType !== dependencySubstitution.testDoubleType) {
            // TODO test case
            throw new errorLib.UsageError("The dependency substitution with id '" + id + "' is not of type '" + criteria.testDoubleType + "'");
        }
        return dependencySubstitution;
    }

    function configure(definition) {
        if (definition !== null && typeof definition === "object" && definition !== null) {
            if (definition.hasOwnProperty("csvPackage")) {
                this.csvPackage = definition.csvPackage;
            }
            if (definition.hasOwnProperty("targetPackage")) {
                this.targetPackage = definition.targetPackage;
            }
            if (definition.hasOwnProperty("mockstarProperties") && typeof definition.mockstarProperties === "object" && definition.mockstarProperties !== null) {
                this.properties.mockstar = definition.mockstarProperties;
            }
            if (definition.hasOwnProperty("csvProperties") && typeof definition.csvProperties === "object" && definition.csvProperties !== null) {
                this.properties.csv = definition.csvProperties;
            }
            if (definition.hasOwnProperty("schema")) {
                this.schema = definition.schema;
            }
            if (definition.hasOwnProperty("model")) {
                this.model = {
                    schema : definition.model.schema || this.schema || "_SYS_BIC",
                    name : definition.model.name || definition.model
                };
                //samir
                var mname = this.model.name
                mname = mname.replace('/', '::')
                if(useSchema) {
                    this.testModel = '"' + this.schema + '"."' + mname + '"'
                }else{
                    this.testModel =  '"' + mname + '"'
                }
            }

            if (definition.hasOwnProperty("substituteTables") && typeof definition.substituteTables === "object" && definition.substituteTables !== null) {
                addDependencySubstitutions.call(this, definition.substituteTables, DependencyType.TABLE, DependencyType.TABLE);
            }
            if (definition.hasOwnProperty("substituteViews") && typeof definition.substituteViews === "object" && definition.substituteViews !== null) {
                addDependencySubstitutions.call(this, definition.substituteViews, DependencyType.VIEW, DependencyType.TABLE);
            }
        }
        return this;
    }

    /**
     * Creates a mockstarEnvironment object with model description and initial definition. Instances of MockstarEnvironment are created by
     * {@link module:mockstarEnvironment~define define}.
     *
     * @inner
     * @memberof module:mockstarEnvironment
     * @constructor
     */
    var MockstarEnvironment = function(definition) {
        this.schema = null;
        this.model = null;
        this.testModel = null;
        this.wasTablesAndModelCreated = false;
        this.properties = {
            csv : {
                separator : ",",
                headers : true,
                decSeparator : "."
            },
            mockstar : {
                truncOption : mockstar.TruncOptions.NONE
            }
        };
        this.csvPackage = null;
        //this.targetPackage = "tmp.unittest." + userSchema.toLowerCase();

        this.dataDefinitions = []; // data is defined to upload
        this.csvFileUpload = []; // csvFile for upload was given
        this.dependencySubstitution = {}; // map of table name aliases to {name, data}

        configure.call(this, definition);
    };

    /**
     * Returns the name of the model to be tested.
     *
     * @method getModelName
     * @returns {String} the name of the model to be tested e.g. "_SYS_BIC"."package.subpackage/ca_view"
     * @memberof module:mockstarEnvironment~MockstarEnvironment.prototype
     */
    MockstarEnvironment.prototype.getModelName = function() {
        return '"' + this.model.schema + '"."' + this.model.name + '"';
    };

    /**
     * Returns the name of the table dependency you have defined within {@link module:mockstarEnvironment~define define} or
     * {@link module:mockstarEnvironment~MockstarEnvironment#addTableSubstitution addTableSubstitution}.
     *
     * @method getTableName
     * @param {String}
     *            id - identifier of the table to be substituted
     * @returns {String} fully qualified table name e.g. "USERSCHEMA"."MY_TEST_TABLE"
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when no table substitution is defined for the given 'id'
     */
    MockstarEnvironment.prototype.getTableName = function(id) {
        var tableSubstitution = getDependencySubstitution.call(this, id, {
            type : DependencyType.TABLE
        });
        return '"' + tableSubstitution.schema + '"."' + tableSubstitution.name + '"';
    };

    /**
     * Returns the name of the view dependency you have defined within {@link module:mockstarEnvironment~define define} or
     * {@link module:mockstarEnvironment~MockstarEnvironment#addViewSubstitution addViewSubstitution}.
     *
     * @method getViewName
     * @param {String}
     *            id - identifier of the view to be substituted
     * @returns {String} fully qualified view name e.g. "_SYS_BIC"."package/any_view"
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error if no view substitution is defined for the given 'id'
     */
    MockstarEnvironment.prototype.getViewName = function(id) {
        var viewSubstitution = getDependencySubstitution.call(this, id, {
            type : DependencyType.VIEW
        });
        return '"' + viewSubstitution.schema + '"."' + viewSubstitution.name + '"';
    };

    /**
     * Returns the name of the procedure dependency you have defined within
     * {@link module:mockstarEnvironment~MockstarEnvironment#addProcedureSubstitution addProcedureSubstitution}.
     *
     * @method getProcedureName
     * @param {String}
     *            id - identifier of the procedure to be substituted
     * @returns {String} fully qualified procedure name e.g. "SCHEMA"."package::any_procedure"
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error if no procedure substitution is defined for the given 'id'
     */
    MockstarEnvironment.prototype.getProcedureName = function(id) {
        var procedureSubstitution = getDependencySubstitution.call(this, id, {
            type : DependencyType.PROCEDURE
        });
        return '"' + procedureSubstitution.schema + '"."' + procedureSubstitution.name + '"';
    };

    /**
     * Describe a table dependency that should be substituted in the copied test model hierarchy.
     *
     * If no 'testTable' property was specified, a copy of the origin table will be created in the user's schema using
     * {@link module:tableUtils~TableUtils#copyIntoUserSchema tableUtils.copyIntoUserSchema}.
     *
     * @method addTableSubstitution
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     *
     * @param {String}
     *            id - identifier of the table to be substituted
     * @param {String|Object}
     *            substitution - the name of the original table without schema e.g. "package.subpackage::context.entity" | the original table with the following
     *            properties:
     * @param {String}
     *            [substitution.schema] - schema of the table to be substituted
     * @param {String}
     *            substitution.name - name of the table to be substituted without schema
     * @param {String}
     *            [substitution.data] - data to be inserted into the test table {@link module:tableUtils~TableUtils#insertData tableUtils.insertData}
     * @param {String}
     *            [substitution.csvFile] - name of the .csv file to be uploaded into the test table. In that case you need to specify
     *            {@link definition.csvPackage}
     * @param {String}
     *            [substitution.testTable] - the full test table name including the schema that should be used as table substitution e.g.
     *            '"TESTSCHEMA"."MY_TEST_TABLE"'
     * @throws an
     *             error when parameter 'id' is not unique
     * @throws an
     *             error when a substitution exists already
     * @throws an
     *             error when '{@link module:mockstarEnvironment~MockstarEnvironment#create create}' function was already called
     * @throws an
     *             error when both properties 'data' and 'csvFile' are given
     * @throws an
     *             error when 'csvFile' was given but no csvPackage was configured in the {@link module:mockstarEnvironment~define define}
     * @see {@link module:mockstarEnvironment~define define}
     */
    MockstarEnvironment.prototype.addTableSubstitution = function(id, substitution) {
        if (this.wasTablesAndModelCreated) {
            throw new errorLib.UsageError("'addTableSubstitution' must be called before 'create'");
        }
        addDependencySubstitution.call(this, id, substitution, DependencyType.TABLE, DependencyType.TABLE);
    };

    /**
     * Describe a view dependency that should be substituted in the copied test model hierarchy.
     *
     * If no 'testTable' property was specified, it will try to create a test table on the base of the origin view in the user's schema using
     * {@link module:tableUtils~TableUtils#createTestTableFromView tableUtils.createTestTableFromView}.
     *
     * @method addViewSubstitution
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @param {String}
     *            id - identifier of the view to be substituted
     * @param {String|Object}
     *            substitution - the name of the original view without schema e.g."package.subpackage/ca_view" | the original view with the following
     *            properties:
     * @param {String}
     *            [substitution.schema=mockstarEnvironment.schema|'_SYS_BIC'] - schema of the view to be substituted
     * @param {String}
     *            substitution.name - name of the view to be substituted without schema
     * @param {String}
     *            [substitution.data] - data to be inserted into the test table {@link module:tableUtils~TableUtils#insertData tableUtils.insertData}
     * @param {String}
     *            [substitution.csvFile] - name of the .csv file to be uploaded into the test table. In that case you need to specify
     *            {@link definition.csvPackage}
     * @param {String}
     *            [substitution.testTable] - the full test table name including the schema that should be used as table substitution e.g.
     *            '"TESTSCHEMA"."MY_TEST_TABLE"'
     *
     * @throws an
     *             error when parameter 'id' is not unique
     * @throws an
     *             error when a substitution exists already
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was already called
     * @throws an
     *             error when both properties 'data' and 'csvFile' are given
     * @throws an
     *             error when 'csvFile' was given but no csvPackage was configured in the {@link module:mockstarEnvironment~define define}
     * @see {@link module:mockstarEnvironment~define define}
     */
    MockstarEnvironment.prototype.addViewSubstitution = function(id, substitution) {
        if (this.wasTablesAndModelCreated) {
            throw new errorLib.UsageError("'addViewSubstitution' must be called before 'create'");
        }
        addDependencySubstitution.call(this, id, substitution, DependencyType.VIEW, DependencyType.TABLE);
    };

    /**
     * Describe a table dependency that should be substituted in the copied test model hierarchy.
     *
     *
     * @method addProcedureSubstitution
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     *
     * @param {String}
     *            id - identifier of the procedure to be substituted
     * @param {Object}
     *            substitution - the original procedure with the following properties:
     * @param {String}
     *            [substitution.schema=mockstarEnvironment.schema] - schema of the procedure to be substituted
     * @param {String}
     *            substitution.name - name of the procedure to be substituted without schema e.g. "package.subpackage::procedure"
     * @param {String}
     *            substitution.testProcedure - the full test procedure name including the schema that should be used as procedure substitution e.g.
     *            '"TESTSCHEMA"."package.subpackage::procedure"'
     * @throws an
     *             error when parameter 'id' is not unique
     * @throws an
     *             error when a substitution exists already
     * @throws an
     *             error when '{@link module:mockstarEnvironment~MockstarEnvironment#create create}' function was already called
     */
    MockstarEnvironment.prototype.addProcedureSubstitution = function(id, substitution) {
        if (this.wasTablesAndModelCreated) {
            throw new errorLib.UsageError("'addProcedureSubstitution' must be called before 'create'");
        }
        if (typeof substitution !== "object" && substitution !== null) {
            // restriction as of now
            throw new errorLib.UsageError("Expected parameter 'substitution' to be an object"); // TODO: "which specifies at least name and testProcedure"
            // necessary?
        }
        addDependencySubstitution.call(this, id, substitution, DependencyType.PROCEDURE, DependencyType.PROCEDURE);
    };

    function validateDependencySubstitution(id) {
        if (!this.dependencySubstitution[id].schema) {
            throw new errorLib.UsageError("No schema defined for dependency substitution '" + id + "'"); // TODO: "or on root level" necessary?
        }
    }

    function mockstarConfigComplete() {
        if (getAllDependencySubstitutions(this).length === 0) {
            throw new errorLib.UsageError("No dependency substitutions defined");
        }
        getAllDependencySubstitutions(this).forEach(validateDependencySubstitution, this);
    }

    function createTestTablesAndViews() {
        var me = this;
        var jasmineInterface = mJasmine.interface()
        var jasmine = jasmineInterface.jasmine
        var tableUtils = new TableUtils(jasmine.dbConnection);
        getAllDependencySubstitutions(me).forEach(function(id) {
            var substitute = me.dependencySubstitution[id];
            if (!substitute.testDouble) {
                if (substitute.type === DependencyType.TABLE) {
                    //samir
                    //substitute.testDouble = tableUtils.copyIntoUserSchema(substitute.schema, substitute.name, id);
                    if(useSchema){
                        substitute.testDouble = '"' + substitute.schema + '"."' + substitute.name + '"';
                    }else{
                        substitute.testDouble =  '"' + substitute.name + '"';
                    }
                } else if (substitute.type === DependencyType.VIEW) {
                    //samir
                    //substitute.testDouble = tableUtils.createTestTableFromView(substitute.name, substitute.name, null, substitute.schema);
                    if(useSchema){
                        substitute.testDouble = '"' + substitute.schema + '"."' + substitute.name + '"';
                    }else{
                        substitute.testDouble = '"' + substitute.name + '"';
                    }
                }
            }
        });
    }

    function grantAccessOnSchemaToSysRepo(testSchema) {
        var sqlExecutor = new SqlExecutor(connection);
        sqlExecutor.execSingle("grant select, insert, update, delete, create any on schema " + testSchema + " to _SYS_REPO with grant option");
    }

    function buildSubstitutionRule(originSchema, originName, testDoubleName) {
        return {
            original : {
                schema : originSchema,
                name : originName
            },
            substitute : testDoubleName
        };
    }

    function createTestModel() {
        var dependencySubstitutions = [];
        var me = this;

        //grantAccessOnSchemaToSysRepo(userSchema);

        getAllDependencySubstitutions(me).forEach(function(id) {
            var substitute = me.dependencySubstitution[id];
            dependencySubstitutions.push(buildSubstitutionRule.call(this, substitute.schema, substitute.name, substitute.testDouble));
        });

        // TODO correct in mockstar - only implicit support of models that are located in schemas other than _SYS_BIC
        // var originModel = '"' + this.model.schema + '"."' + this.model.name + '"';
        this.testModel = mockstar.createTestModel(this.model.name, this.targetPackage, dependencySubstitutions, this.properties.mockstar.truncOption).runTimePath;
    }

    /**
     * This function
     * <ul>
     * <li>creates a test table into the user schema as copy of each table dependency to be substituted - unless an existing testTable was defined ({@link module:tableUtils~TableUtils#copyIntoUserSchema tableUtils.copyIntoUserSchema})</li>
     * <li>creates a test table into the user schema for each view dependency to be substituted - unless an existing testTable was defined ({@link module:tableUtils~TableUtils#createTestTableFromView tableUtils.createTestTableFromView}</li>
     * <li>creates a copy of the original model into the target package where all specified dependencies were replaced by the test tables ({@link module:mockstar~createTestModel mockstar.createTestModel})</li>
     * <li>inserts the specified data into the created test tables ({@link module:tableUtils~TableUtils#insertData tableUtils.insertData})</li>
     * <li>uploads data from the specified csvFile into the created test tables ({@link module:tableUtils~TableUtils#fillFromCsvFile tableUtils.fillFromCsvFile}).</li>
     * </ul>
     * Note that this function is not repeatable, it can only be called once per mockstarEnvironment object.
     *
     * @method create
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @returns {MockstarEnvironment}
     *
     * @throws an
     *             error when for any table/view name the schema is missing
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was already called
     * @throws an
     *             error when an error occurs in one of the underlying utility functions
     */
    MockstarEnvironment.prototype.create = function() {
        if (this.wasTablesAndModelCreated) {
            throw new errorLib.UsageError("'create' has already been called");
        }
        mockstarConfigComplete.call(this);
        createTestTablesAndViews.call(this);
        //createTestModel.call(this);
        this.wasTablesAndModelCreated = true;
        var i = 0;
        var id = "";
        for (i = 0; i < this.dataDefinitions.length; i++) {
            id = this.dataDefinitions[i];
            this.fillTestTable(id, this.dependencySubstitution[id].data);
        }
        for (i = 0; i < this.csvFileUpload.length; i++) {
            id = this.csvFileUpload[i];
            this.fillTestTableFromCsv(id, this.dependencySubstitution[id].csvFile);
        }
        return this;
    };

    function validateDefinition(definition) {
        if (!definition.hasOwnProperty("model")) {
            throw new errorLib.UsageError("Property 'model' not defined");
        }
    }

    function checkTablesAndModelWhereCreated(mockstarEnvironment) {
        if (!mockstarEnvironment.wasTablesAndModelCreated) {
            throw new errorLib.UsageError("'create' has not been called. No test tables and models were created.");
        }
    }

    /**
     * Returns the names of all test tables.
     *
     * @method getTestTableNames
     * @returns {Array} list of test tables e.g. ['"USERSCHEMA"."T1"', '"USERSCHEMA"."T2"']
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     */
    MockstarEnvironment.prototype.getTestTableNames = function() {
        var testTableNames = [];
        var me = this;

        checkTablesAndModelWhereCreated(this);
        getAllDependencySubstitutions(me).forEach(function(id) {
            var substitution = me.dependencySubstitution[id];
            //samir
            //if (substitution.testDouble && substitution.testDoubleType === DependencyType.TABLE) {
            if (substitution.testDoubleType === DependencyType.TABLE) {
                //samir testTableNames.push(substitution.testDouble);
                if(useSchema){
                    var fullTableName = '"' + substitution.schema + '"."' + substitution.name + '"'
                }else{
                    var fullTableName =  '"' + substitution.name + '"'
                }
                testTableNames.push(fullTableName);
            }
        });
        return testTableNames;
    };

    /**
     * Returns the full name of the test table for a given dependency substitution.
     *
     * @method getTestTableName
     * @param {String}
     *            id - identifier of the table/view to be substituted
     * @returns {String} fully qualified name of the test table e.g. '"USERSCHEMA"."T2"'
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     * @throws an
     *             error when no dependency substitution is specified for the given 'id'
     */
    MockstarEnvironment.prototype.getTestTableName = function(id) {
        //checkTablesAndModelWhereCreated(this);
        var substitution = getDependencySubstitution.call(this, id, {
            testDoubleType : DependencyType.TABLE
        });

        if(!substitution){
            throw new Error('Test substitution not found ' +id)
        }

        /*
         var connection = jasmine.dbConnection
         if(!connection.substitutions){
         connection.substitutions = {}
         }

         if(!connection.substitutions[id]){
         var tableUtils = new utils.TableUtils(connection)
         substitute.testDouble = tableUtils.copyIntoUserSchema(substitute.schema, substitute.name, id)
         connection.substitutions[id] = substitute

         if(substitute.data){
         this.fillTestTable(id, substitute.data)
         }else if(substitute.csvFile){
         this.fillTestTableFromCsv(id, substitute.csvFile)
         }
         }
         */

        //samir
        return substitution.testDouble;
        //return '"'+ substitution.schema +'"."' + substitution.name + '"'
    };

    /**
     * Returns the full name of the test procedure for a given dependency substitution.
     *
     * @method getTestProcedureName
     * @param {String}
     *            id - identifier of the procedure to be substituted
     * @returns {String} fully qualified name of the test procedure e.g. '"TESTSCHEMA"."package::procedure"'
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     * @throws an
     *             error when no dependency substitution is specified for the given 'id'
     */
    MockstarEnvironment.prototype.getTestProcedureName = function(id) {
        checkTablesAndModelWhereCreated(this);
        var substitution = getDependencySubstitution.call(this, id, {
            testDoubleType : DependencyType.PROCEDURE
        });
        return substitution.testDouble;
    };

    /**
     * Returns the full name of the test model that was created into the target package.
     *
     * @method getTestModelName
     * @returns {String} fully qualified name of the created test model (including schema)
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     */
    MockstarEnvironment.prototype.getTestModelName = function() {
        checkTablesAndModelWhereCreated(this);
        return this.testModel;
    };

    /**
     * Inserts the specified data into the created test tables.
     *
     * @method fillTestTable
     * @param {String}
     *            id - identifier of the view/table to be substituted
     * @param {Object}
     *            data - specify column specific values
     *
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     * @throws an
     *             error when no dependency substitution is specified for the given 'id'
     * @throws an
     *             error when an error happens in the underlying {@link module:tableUtils~TableUtils#insertData tableUtils.insertData} function
     *
     * @example
     *
     * <pre>
     * var singleEntry = {
	 *     Id : &quot;1&quot;,
	 *     col2 : &quot;A&quot;,
	 *     COL3 : 10.1
	 * };
     * var multEntries = {
	 *     Id : [ &quot;1&quot;, &quot;2&quot; ],
	 *     col2 : [ &quot;A&quot;, &quot;B&quot; ],
	 *     COL3 : [ 10.1, 20.2 ]
	 * };
     *
     * testEnvironment.fillTestTable(&quot;tableId&quot;, singleEntry);
     * testEnvironment.fillTestTable(&quot;tableId&quot;, multEntries);
     * </pre>
     *
     * @see {@link module:tableUtils~TableUtils#insertData tableUtils.insertData}
     */
    MockstarEnvironment.prototype.fillTestTable = function(id, data) {
        var jasmineInterface = mJasmine.interface()
        var jasmine = jasmineInterface.jasmine
        checkTablesAndModelWhereCreated(this);
        var tableUtils = new TableUtils(jasmine.dbConnection);
        var fullTableName = this.getTestTableName(id);
        tableUtils.insertData(fullTableName, data);
        if (this.onDataInserted) {
            this.onDataInserted(fullTableName);
        }
    };

    /**
     * Uploads data from the specified csvFile into the created test tables.
     *
     * @method fillTestTableFromCsv
     * @param {String}
     *            id - identifier of the view/table to be substituted
     * @param {String}
     *            csvFile - name of the .csv file
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     * @throws an
     *             error when no dependency substitution is specified for the given 'id'
     * @throws an
     *             error when an error happens in the underlying {@link module:tableUtils~TableUtils#fillFromCsvFile tableUtils.fillFromCsvFile} function
     * @see {@link module:tableUtils~TableUtils#fillFromCsvFile tableUtils.fillFromCsvFile}
     */
    MockstarEnvironment.prototype.fillTestTableFromCsv = function(id, csvFile) {
        checkTablesAndModelWhereCreated(this);
        if (!this.csvPackage) {
            throw new errorLib.UsageError("Property 'csvPackage' not defined");
        }
        var tableUtils = new TableUtils(connection);
        var fullTableName = this.getTestTableName(id);
        tableUtils.fillFromCsvFile(fullTableName, this.csvPackage, csvFile, this.properties.csv);
        if (this.onDataInserted) {
            this.onDataInserted(fullTableName);
        }
    };

    /**
     * Commits the current database connection (connection), which will store all data modifications, which were done to the database tables.
     *
     * This might be relevant, if you insert data into the test tables within the beforeOnce function, which should be available within the test specification
     * (i.e. test case).
     *
     * The managed database connection (connection) is ... ... opened before the execution of each beforeOnce and each afterOnce and closed after the
     * execution. ... opened before the first of each test specification (i.e. test case), stays open while the test spec and its corresponding beforeEach and
     * afterEach functions are executed and it's closed after the last afterEach.
     *
     * @method commitData
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @see {@link module:mockstarEnvironment~define define}
     */
    MockstarEnvironment.prototype.commitData = function() {
        connection.commit();
    };

    function clearTestTable(tableUtils, id) {
        checkTablesAndModelWhereCreated(this);
        tableUtils.clearTableInUserSchema(this.getTestTableName(id));
    }

    /**
     * Clears the test tables for some given dependency substitutions. Note that the test tables need to be located in the userSchema.
     *
     * @method clearTestTables
     * @param {Array}
     *            ids - list of identifiers of the table to be substituted
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     * @throws an
     *             error when no dependency substitution is specified for one of the given 'ids'
     * @throws an
     *             error when an error happens in the underlying {@link module:tableUtils~TableUtils#clearTableInUserSchema tableUtils.clearTableInUserSchema}
     *             function
     * @see {@link module:tableUtils~TableUtils#clearTableInUserSchema tableUtils.clearTableInUserSchema}
     *
     */
    MockstarEnvironment.prototype.clearTestTables = function(ids) {
        if (!Array.isArray(ids)) {
            throw new errorLib.UsageError("Expected parameter 'ids' to be of type Array");
        }
        var tableUtils = new TableUtils(connection);
        ids.forEach(clearTestTable.bind(this, tableUtils));
    };

    /**
     * Clears the test tables for all given dependency substitutions. Note that all test tables need to be located in the userSchema.
     *
     * @method clearAllTestTables
     * @memberof! module:mockstarEnvironment~MockstarEnvironment.prototype
     * @throws an
     *             error when {@link module:mockstarEnvironment~MockstarEnvironment#create create} function was not yet called
     * @throws an
     *             error when an error happens in the underlying {@link module:tableUtils~TableUtils#clearTableInUserSchema tableUtils.clearTableInUserSchema}
     *             function
     * @see {@link module:tableUtils~TableUtils#clearTableInUserSchema tableUtils.clearTableInUserSchema}
     */
    MockstarEnvironment.prototype.clearAllTestTables = function() {
        var jasmineInterface = mJasmine.interface()
        var jasmine = jasmineInterface.jasmine
        var connection = jasmine.dbConnection
        var tableUtils = new TableUtils(connection);
        this.getTestTableNames().forEach(tableUtils.clearTableInUserSchema.bind(tableUtils));
        //connection.close()

        //jasmine.dbConnection.close()
        //jasmine.dbConnection = $.db.getConnection()
    };

    /**
     * Creates a MockstarEnvironment object with an initial definition. MockstarEnvironment offers functions that helps you to test a model (e.g. view or
     * procedure) in an isolated way. It offers functions to:
     * <ul>
     * <li>define the test model</li>
     * <li>define the dependent tables/views that should be replaced in the test model by test tables</li>
     * <li>fill those test tables with data/from csv file.</li>
     * </ul>
     *
     * Note that for each dependent table/view a test table is created automatically via the test helper functions
     * {@link module:tableUtils~TableUtils#copyIntoUserSchema tableUtils.copyIntoUserSchema} and
     * {@link module:tableUtils~TableUtils#createTestTableFromView tableUtils.createTestTableFromView} unless you have specified the test table explicitly via
     * the 'testTable' property.
     *
     *
     * @example
     *
     * <pre>
     * var mockstarEnvironment = $.import(&quot;sap.hana.testtools.mockstar&quot;, &quot;mockstarEnvironment&quot;);
     *
     * var testData = { Id: &quot;1&quot;, col2: &quot;A&quot;, COL3: 10.1 };
     * var definition = {
	 *       schema: &quot;SCHEMA&quot;,
	 *       model: {
	 *               schema : &quot;_SYS_BIC&quot;,
	 *               name: &quot;package.subpackage/calculationview&quot;,
	 *       }
	 *       substituteTables: {
	 *           &quot;table_id&quot;: {
	 *               name: &quot;package.db::basis.t_table&quot;,
	 *               csvFile: &quot;table.csv&quot;
	 *           }
	 *       }
	 *       substituteViews: {
	 *           &quot;view_id&quot;: {
	 *               name: &quot;package.db::basis.v_item&quot;,
	 *               testTable: '&quot;USER&quot;.&quot;v_item_table&quot;',
	 *               data: testData
	 *           }
	 *       }
	 * };
     * var testEnvironment = mockstarEnvironment.define(definition);
     * </pre>
     *
     * @param {Object}
     *            definition
     * @param {String}
     *            [definition.schema] - the schema, that should be used, when no schema is explicitly specified
     * @param {String|Object}
     *            definition.model - the name of the original model without schema or the original model with the properties as described below
     * @param {String}
     *            [definition.model.schema=definition.schema|"_SYS_BIC"] - the schema of the original model
     * @param {String}
     *            [definition.model.name] - the name of the original model (without schema), e.g. "package.subpackage/ca_view"
     * @param {String}
     *            [definition.targetPackage="tmp.unittest.&lt;username&gt"] - the package name where the test model should be created into
     * @param {Object}
     *            [definition.mockstarProperties] - defines the options for {@link module:mockstar~createTestModel mockstar.createTestModel}
     * @param {String}
     *            [definition.mockstarProperties.truncOption=TruncOptions.NONE] - per default the target package gets prefixed with the package of the original
     *            model
     * @param {String}
     *            [definition.csvPackage] - the package name of the .csv files
     * @param {Object}
     *            [definition.csvProperties] - defines the options for {@link module:tableUtils~TableUtils#fillFromCsvFile tableUtils.fillFromCsvFile}
     * @param {String}
     *            [definition.csvProperties.separator=";"] - overwrites the value separator
     * @param {Boolean}
     *            [definition.csvProperties.headers=true] - indicates whether the data contains a header line
     * @param {String}
     *            [definition.csvProperties.decSeparator="."] - overwrites the decimal separator
     * @param {Object}
     *            [definition.substituteTables] list of table dependencies that should be substituted within the copied test model hierarchy
     * @param {String|Object}
     *            definition.substituteTables.&lt;id&gt; - the name of the original table without schema
     *
     * <pre>
     * &quot;tableId&quot;: &quot;package.subpackage::context.entity&quot;
     * </pre>
     *
     * or the original table with the properties as described below
     *
     * <pre>
     * &quot;tableId&quot;: {...}
     * </pre>
     *
     * @param {String}
     *            [definition.substituteTables.&lt;id&gt;.schema=definition.schema] - schema of the table to be substituted
     * @param {String}
     *            definition.substituteTables.&lt;id&gt;.name - name of the table to be substituted (without schema)
     * @param {String}
     *            [definition.substituteTables.&lt;id&gt;.data] - data to be inserted into the test table
     *            {@link module:tableUtils~TableUtils#insertData tableUtils.insertData}
     * @param {String}
     *            [definition.substituteTables.&lt;id&gt;.csvFile] - name of the .csv file to be uploaded into the test table. In that case you need to specify
     *            {@link definition.csvPackage}
     * @param {String}
     *            [definition.substituteTables.&lt;id&gt;.testTable] - the full test table name including the schema that should be used as table substitution
     *            e.g. '"TESTSCHEMA"."MY_TEST_TABLE"'
     * @param {Object}
     *            [definition.substituteViews] list of view dependencies that should be substituted within the copied test model hierarchy
     * @param {String|Object}
     *            definition.substituteViews.&lt;id&gt; - the name of the original view without schema
     *
     * <pre>
     * &quot;viewId&quot;: &quot;package.subpackage/ca_view&quot;
     * </pre>
     *
     * or the original view with the properties as described below
     *
     * <pre>
     * &quot;viewId&quot;: {...}
     * </pre>
     *
     * @param {String}
     *            [definition.substituteViews.&lt;id&gt;.schema=definition.schema|"_SYS_BIC"] - schema of the view to be substituted
     * @param {String}
     *            definition.substituteViews.&lt;id&gt;.name - name of the view to be substituted (without schema)
     * @param {String}
     *            [definition.substituteViews.&lt;id&gt;.data] - data to be inserted into the test table
     *            {@link module:tableUtils~TableUtils#insertData tableUtils.insertData}
     * @param {String}
     *            [definition.substituteViews.&lt;id&gt;.csvFile] - name of the .csv file to be uploaded into the test table. In that case you need to specify
     *            {@link definition.csvPackage}
     * @param {String}
     *            [definition.substituteViews.&lt;id&gt;.testTable] - the full test table name including the schema that should be used as table substitution
     *            e.g. '"TESTSCHEMA"."MY_TEST_TABLE"'
     *
     * @returns {module:mockstarEnvironment~MockstarEnvironment} Mockstar environment object that contains several definition methods to create a test model and
     *          test tables in order to test a model in an isolated way.
     * @see {@link module:mockstarEnvironment~defineAndCreate defineAndCreate}
     */
    define = function(definition) {
        validateDefinition(definition);
        return new MockstarEnvironment(definition);
    };

    /**
     * Creates a MockstarEnvironment Object with a given definition. After calling this function the test model as well as the defined test tables are created ({@link module:mockstarEnvironment~MockstarEnvironment#create mockstarEnvironment.create}).<br>
     * Equivalent to
     *
     * <pre class="prettyprint"><code>
     * &lt;pre&gt;
     * define(definition).create()
     * &lt;/pre&gt;
     * </code></pre>
     *
     * @param {Object}
     *            definition like in {@link module:mockstarEnvironment~define mockstarEnvironment.define}
     *
     * @see {@link module:mockstarEnvironment~MockstarEnvironment#create mockstarEnvironment.create}
     * @returns {module:mockstarEnvironment~MockstarEnvironment} mockstarEnvironment that contains several definition methods to fill test tables in order to
     *          test a model in an isolated way.
     *
     */
    defineAndCreate = function(definition) {
        var mockstarEnvironment = define(definition);
        return mockstarEnvironment.create();
    };

    /**
     * This event is triggered every time data is inserted into a test table, which is known to mockstarEnvironment.
     *
     * @param {String}
     *            fullTableName the fully qualified table name
     */
    MockstarEnvironment.prototype.onDataInserted = null;



module.exports = {
    define : define,
    defineAndCreate : defineAndCreate
}
