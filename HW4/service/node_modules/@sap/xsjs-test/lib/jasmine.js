var path = require('path')
var mUtil = require('util')
var _ = require('lodash')

var Fiber = require('@sap/fibers')

var JasmineConsoleReporter = require('jasmine-console-reporter');

var tableDataSet = require('./util/tableDataSet.js')
var tableComparator = require('./util/tableComparator.js')
var mReporter = require('./reporter')
const utils = require('@sap/xsjs/lib/utils');




function matchers(jasmine){
    return {
        toEqual : function(util, customEqualityTesters) {
            function toEqual(actual, expected) {
                var objectsAreEqual;
                if(expected instanceof jasmine.Any) {
                    objectsAreEqual = actual instanceof expected.expectedObject;
                } else if(actual instanceof jasmine.Any) {
                    objectsAreEqual = expected instanceof actual.expectedObject;
                } else {
                    objectsAreEqual = _.isEqual(actual, expected);
                }
                
                if(objectsAreEqual) {
                    return {
                        pass: true
                    }
                } else {
                    return {
                        pass: false,
                        message : "Actual " + mUtil.inspect(actual) + " <> expected " + mUtil.inspect(expected)
                    }
                }
            }

            return {
                compare : toEqual
            }
        },

        toEqualObject : function(util, customEqualityTesters) {
            /**
             * <strong>Caution:</strong> This currently behaves exactly {@link jasmine.Expectation#toEqual}.<br>
             *
             * Compares two objects.
             *
             * Since the output format of the standard {@link jasmine.Expectation.prototype.toEqual} matcher in some instances makes it hard to spot the actual
             * differences between two complicated objects, this matcher provides an improved reporting of the found discrepancies. Similar to the
             * <code>toMatchData</code> function, it reports differences in objects in three different categories: missing properties, extraneous properties and
             * matching properties with different values.
             *
             * @memberof jasmine.Expectation.prototype
             * @param {Object}
             *            expected any object
             *
             */
            function toEqualObject(actual, expected) {
                /*jslint unparam:true*/
                return jasmine.matchers.toEqual(util, customEqualityTesters).compare.apply(this, arguments)
             }

            return {
                compare : toEqualObject
            }
        },
        toEqualString : function() {
            function customQuote(openingDelimiter, closingDelimiter, str) {
                return openingDelimiter + str + closingDelimiter;
            }

            function toEqualString(actualRaw, expectedRaw) {
                var result = {
                    pass: true
                };
                var actual = "";
                actual += actualRaw;
                var expected = "";
                expected += expectedRaw;

                var cutLeading = 0;
                var maxlen = Math.min(actual.length, expected.length);
                while (cutLeading < maxlen && actual[cutLeading] === expected[cutLeading]) {
                    ++cutLeading;
                }
                if (actual.length !== expected.length || cutLeading < actual.length) {
                    maxlen -= cutLeading;
                    var cutTrailing = 0;
                    while (cutTrailing < maxlen && actual[actual.length - cutTrailing - 1] === expected[expected.length - cutTrailing - 1]) {
                        ++cutTrailing;
                    }

                    var trimmedActual = actual.substring(cutLeading, actual.length - cutTrailing);
                    var trimmedExpected = expected.substring(cutLeading, expected.length - cutTrailing);
                    var details = [];
                    if (cutLeading) {
                        details.push(cutLeading + " leading");
                    }
                    if (cutTrailing) {
                        details.push(cutTrailing + " trailing");
                    }
                    details = details.length > 0 ? " (skipped common characters: " + details.join(", ") + ")" : "";
                    // var delimiter = trimmedActual.length + trimmedExpected.length > 100 ? "\n" : " ";
                    var delimiter = " ";
                    var quote = customQuote.bind(null, delimiter + "'", "'" + delimiter);
                    result.pass = false;
                    result.message = "Expected" + quote(trimmedActual) + " to equal " + quote(trimmedExpected) + details;
                } else {
                    result.message = "Expected string not to equal '" + expected + "'";
                }

                return result;
            }

            return {
                compare : toEqualString
            }
        },
        toMatch : function toMatchFactory(util, customEqualityTesters){
            return {
                compare : function toMatch(actual, expected, modifier) {
                    var regexp = expected

                    if( typeof regexp == 'string' ){
                        regexp = new RegExp(expected, modifier || "")
                    }
                    return {
                        pass : regexp.test(actual)
                    }
                }
            }
        },
        toMatchData: function toMatchData( util, customEqualityTesters) {
            customEqualityTesters = customEqualityTesters || [];

            function isEqual(a, b) {
                return jasmine.matchersUtil.equals(a, b, customEqualityTesters)
            }

            return {
                compare: function (actual, expected, keyFields) {

                    var actDataSet = tableDataSet.createDataSet(actual);
                    var expDataSet = tableDataSet.createDataSet(expected);
                    var compareResult = tableComparator.compareDataSets(actDataSet, expDataSet, keyFields, isEqual)

                    var fail = false
                    var message = ''
                    var keys
                    if(compareResult.rowsExpectedOnly && compareResult.rowsExpectedOnly.length){
                        fail = true
                        keys = compareResult.rowsExpectedOnly.map(function(row){return row.key}).join(',')
                        message = mUtil.format('missing %s expected rows - keys %s', compareResult.rowsExpectedOnly.length, keys)
                    }

                    if(compareResult.rowsActualOnly && compareResult.rowsActualOnly.length){
                        fail = true
                        keys = compareResult.rowsActualOnly.map(function(row){return row.key}).join(',')
                        message += mUtil.format('\n%s actual rows not expected - keys %s', compareResult.rowsActualOnly.length, keys)
                    }

                    if(compareResult.rowsCommonDiffering && compareResult.rowsCommonDiffering.length){
                        fail = true
                        keys = compareResult.rowsCommonDiffering.map(function(row){return row.key}).join(',')
                        message += mUtil.format('\nNot matching rows - keys %s', keys)
                    }

                    message = mUtil.format('Expected set <> actual set \n%s', message)

                    var result = {
                        matcherName: "toMatchData",
                        pass: !fail,
                        expected: actual,
                        actual: expected,
                        message: message
                    }

                    /*
                    function commitPendingResult() {
                        jasmine.getEnv().currentSpec.addExpectationResult(false, result)
                    }

                    function addPendingResult(act, exp, msg) {
                        if (this.isNot) {
                            result.pass = false
                            return
                        }
                        if (!result.pass) {
                            commitPendingResult()
                        }
                        result = {
                            matcherName: "toMatchData",
                            pass: false,
                            expected: exp,
                            actual: act,
                            message: msg,
                            error: new Error(msg)
                        };
                    }

                    compareResult.rowsExpectedOnly.forEach(function (row) {
                        addPendingResult(undefined, row, "Expected row " + jasmine.pp(row) + " was missing")
                    })
                    compareResult.rowsActualOnly.forEach(function (row) {
                        addPendingResult(row, undefined, "Actual row " + jasmine.pp(row) + " was not expected")
                    })
                    compareResult.rowsCommonDiffering.forEach(function (row) {
                        addPendingResult(row.actual, row.expected, "Actual row with key " + jasmine.pp(row.key) + " differed from expected row: " + jasmine.pp(row.diff))
                    })*/

                    return result
                }//compare

            }//return
        }//toMatchData
    }
}//matchers


var jasmineInterface
var jasmine
var jasmineEnv

var fnSuiteExecute


function load(context, runOptions){
    delete require.cache['jasmine-core']
    var jasmineCoreModule = require('jasmine-core')

    var jasmine = jasmineCoreModule.core(jasmineCoreModule)
    var customMatchers = matchers(jasmine)

    _.assign(jasmine.matchers ,customMatchers)
    jasmineEnv = jasmine.getEnv()
    jasmineInterface = jasmineCoreModule.interface(jasmine, jasmineEnv)

    jasmine = jasmineInterface.jasmine
    jasmine.Suite.prototype.addTags = function addTags(tags) {
        this.tags = Array.isArray(tags) ? tags : Array.slice(arguments)
        return this
    }
    //jasmine.callHTTPService = callHTTPService

    fnSuiteExecute = jasmine.Suite.prototype.execute

    fnSuiteExecuteInFiber = function(){
        var self = this
        var _args = arguments
        Fiber(function(){
            fnSuiteExecute.apply(self,_args)
        }).run()
    }


    fnSpecExecute = jasmine.Spec.prototype.execute

    fnSpecExecuteInFiber = function(){
        var self = this
        var _args = arguments
        Fiber(function(){
            fnSpecExecute.apply(self,_args)
        }).run()
    }

    jasmine.Spec.prototype.execute = fnSpecExecuteInFiber

    jasmineInterface.beforeOnce = function beforeOnce(fn){
        jasmineInterface.beforeAll(fn)
    }

    jasmineInterface.afterOnce = function afterOnce(fn){
        jasmineInterface.afterAll(fn)
    }

    var fnIt = jasmineInterface.it
    jasmineInterface.it = function it(){
        var fnPrepareStackTrace = Error.prepareStackTrace
        Error.prepareStackTrace = function (err, stack) { return stack }
        var stack = new Error().stack
        stack.shift()
        var callsite = stack[0]
        Error.prepareStackTrace = fnPrepareStackTrace
        var spec = fnIt.apply(this,arguments)

        var scriptPath = callsite.getScriptNameOrSourceURL();
        scriptPath = path.normalize(path.relative(process.cwd(), scriptPath));

        spec.result.__resource = {
            filename : scriptPath,
            linenr : callsite.getLineNumber()
        }
        return spec
    }

    function describeWrapper(fnDescribe, args) {
        var fnPrepareStackTrace = Error.prepareStackTrace
        Error.prepareStackTrace = function (err, stack) { return stack }
        var stack = new Error().stack
        stack.shift()
        stack.shift()
        var callsite = stack[0]
        Error.prepareStackTrace = fnPrepareStackTrace

        var scriptPath = callsite.getScriptNameOrSourceURL();
        scriptPath = path.normalize(path.relative(process.cwd(), scriptPath));
        const rootDirs = runOptions.rootDirs;
        const pattern = new RegExp(runOptions.test.pattern);
        let libId = null;
        for (let index = 0; index < rootDirs.length; index++) {
            const relativeDir = path.relative(process.cwd(), rootDirs[index]);
            if (scriptPath.startsWith(relativeDir)) {
                libId = utils.toResourceId(scriptPath.slice(relativeDir.length));
                break;
            }
        }
        if (!libId.match(pattern)) {
            return;
        }

        var suite = fnDescribe.apply(this, args)

        suite.result.__resource = {
            filename : scriptPath,
            linenr : callsite.getLineNumber()
        }
        return suite
    }

    var fnDescribe = jasmineInterface.describe
    jasmineInterface.describe = function describe(){
        return describeWrapper.call(jasmineInterface, fnDescribe, Array.prototype.slice.apply(arguments));
    }

    var fnXdescribe = jasmineInterface.xdescribe
    jasmineInterface.xdescribe = function describe(){
        const suite =  describeWrapper.call(jasmineInterface, fnXdescribe, Array.prototype.slice.apply(arguments));
       if (suite) {
            if (_.isArray(suite.afterAllFns)) {
                suite.afterAllFns.splice(0);
            }
            if (_.isArray(suite.beforeAllFns)) {
                suite.beforeAllFns.splice(0);
            }
        }
        return suite;
    }

    Object.defineProperty(jasmine, "dbConnection", {
        configurable : true,
        enumerable : true,
        get : function getDbConnection() {
            return context.db.getConnection()
			/*
             if(jasmine._connection && !jasmine._connection.isClosed()){
             return jasmine._connection
             }else{
             return jasmine._connection = xsdb.getConnection()
             }*/
        }
    })
    return jasmineInterface
}


function execute(options, callback){
    if(!jasmineInterface){
        jasmineInterface = load()
    }

    var profile = options.test.profile
    if(profile){
        var aProfile
        if(Array.isArray(profile)){
            aProfile = profile
        }else if(typeof profile =='string'){
            aProfile = profile
            aProfile = profile.split(',')
        }else{
            throw new Error('Fail to execute jasmine tests - do not understand profile parameter. Expected array of tags or comma separated list : ' + options.profile)
        }

        jasmineInterface.jasmine.Suite.prototype.execute = function(){
            var common = _.intersection(this.tags, aProfile)
            if(common && common.length){
                fnSuiteExecuteInFiber.call(this, arguments)
            }else{
                console.log('Skip suite '+this.getFullName())
            }
        }
    }else{
        jasmineInterface.jasmine.Suite.prototype.execute = fnSuiteExecuteInFiber
    }

    var reporter = mReporter.createReporter(options, jasmineInterface)
    reporter.initialize()
    jasmineEnv.addReporter(reporter)

    var consoleReporter = new JasmineConsoleReporter({
        colors: 1,           // (0|false)|(1|true)|2 
        cleanStack: 1,       // (0|false)|(1|true)|2|3 
        verbosity: 4,        // (0|false)|1|2|(3|true)|4 
        listStyle: 'indent', // "flat"|"indent" 
        activity: false
    });
    jasmineEnv.addReporter(consoleReporter);

    jasmineInterface.jsApiReporter.jasmineDone = function(){
        var output = reporter.getResults()
        var contentType = reporter.getContentType()
        callback(output, contentType)
    }
    jasmineEnv.addReporter(jasmineInterface.jsApiReporter)

    jasmineEnv.execute()
}

function getEnv() {
    return jasmineEnv || {};
}

module.exports = {
    load : load,

    interface : function(){
        return jasmineInterface
    },

    execute : execute,

    getEnv : getEnv
}
