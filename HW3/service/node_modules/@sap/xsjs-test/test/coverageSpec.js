var expect = require("expect.js");

var fs = require("fs");
var path = require("path");

var coverage = require("../lib/coverage.js");

var sinon = require("sinon");

var sandbox;

describe("coverage.js tests", function () {
    beforeEach(function () {
        sandbox = sinon.sandbox.create();
    });

    afterEach(function () {
        sandbox.restore();
    });

    it("makes paths relative correctly", function () {

        var runOptions = {
            coverage: {},
            test: {}
        };
        var Coverage = coverage(runOptions);
        var cov = new Coverage();

        var coverageObject = {
            "/a1": {
                path: "/folder/1"
            },
            "/a2": {
                path: "/folder/2"
            }
        };
        var baseFolder = "/base/folder";

        var result = cov._makeRelative(coverageObject, baseFolder);

        var keyA1 = path.join("..", "..", "a1");
        expect(result).to.have.key(keyA1);
        expect(result[keyA1]).to.have.property("path", path.join("..", "..", "folder", "1"));

        var keyA2 = path.join("..", "..", "a2");
        expect(result).to.have.key(keyA2);
        expect(result[keyA2]).to.have.property("path", path.join("..", "..", "folder", "2"));
    });

    it("finds files in mixin's get method", function () {
        var mockFs = sandbox.mock(fs);
        mockFs.expects("existsSync").withArgs("a").returns(false);
        mockFs.expects("existsSync").withArgs(path.join("x", "a")).returns(false);
        mockFs.expects("existsSync").withArgs(path.join("y", "a")).returns(true);
        mockFs.expects("readFileSync").withArgs(path.join("y", "a"), "utf8");
        mockFs.expects("mkdirSync");

        var runOptions = {
            coverage: {},
            test: {},
            rootDirs: [
                "x",
                "y"
            ]
        };
        var Coverage = coverage(runOptions);
        var cov = new Coverage();

        var result = cov._mixIn.keys();
        expect(result).to.be.empty();

        // get returns file content. since fs is mocked (see readFileSync)
        // no need to validate mock file content
        cov._mixIn.get("a");

        expect(mockFs.verify()).to.be.ok();
    });

    it("finds files in mixin's hasKey method when file exists in root", function () {
        var mockFs = sandbox.mock(fs);
        mockFs.expects("existsSync").withArgs("a").returns(true);
        mockFs.expects("mkdirSync");

        var runOptions = {
            coverage: {},
            test: {},
            rootDirs: [
                "x",
                "y"
            ]
        };
        var Coverage = coverage(runOptions);
        var cov = new Coverage();

        var result = cov._mixIn.hasKey("a");
        expect(result).to.be.ok();

        expect(mockFs.verify()).to.be.ok();
    });

    it("finds files in mixin's hasKey method when file exists in any root dir", function () {
        var mockFs = sandbox.mock(fs);
        mockFs.expects("existsSync").withArgs("a").returns(false);
        mockFs.expects("mkdirSync");
        mockFs.expects("statSync").withArgs(path.join("x", "a")).returns({
            isFile: function () {
                return false;
            }
        });
        mockFs.expects("statSync").withArgs(path.join("y", "a")).returns({
            isFile: function () {
                return true;
            }
        });

        var runOptions = {
            coverage: {},
            test: {},
            rootDirs: [
                "x",
                "y"
            ]
        };
        var Coverage = coverage(runOptions);
        var cov = new Coverage();

        var result = cov._mixIn.hasKey("a");
        expect(result).to.be.ok();

        expect(mockFs.verify()).to.be.ok();
    });
});