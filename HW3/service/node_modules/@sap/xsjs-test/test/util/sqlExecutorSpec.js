var expect = require("expect.js");
var sinon = require("sinon");
var assert = require('chai').assert;

var SQLExecutor = require("../../lib/util/sqlExecutor.js");
var HDBConnection = require("@sap/xsjs/lib/xsjs/db/hdbapi/Connection.js");
var DBConnection = require("@sap/xsjs/lib/xsjs/db/dbapi/Connection.js");
var ResultSet = require("@sap/xsjs/lib/xsjs/db/dbapi/ResultSet.js");
var DBPreparedStatement = require("@sap/xsjs/lib/xsjs/db/dbapi/PreparedStatement.js");

var sandbox;

describe("util/sqlExecutor.js tests", function () {
    beforeEach(function () {
        sandbox = sinon.sandbox.create();
    });

    afterEach(function () {
        sandbox.restore();
    });

    it("calls execSingle with db connection correctly", function () {
        var sql = "select * from (*)";

        // workaround to create statement mock since original constructor requires
        // additional info
        var statement = DBPreparedStatement.prototype;
        var mockStatement = sandbox.mock(statement);
        mockStatement.expects("execute");
        mockStatement.expects("close");

        var connection = new DBConnection({});
        var mockConnection = sandbox.mock(connection);
        mockConnection.expects("prepareStatement").withArgs(sql).returns(statement);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(mockConnection.verify()).to.be.ok();
        expect(mockStatement.verify()).to.be.ok();
    });

    it("calls execSingle with hdb connection correctly", function () {
        var sql = "select * from (*)";

        var connection = new HDBConnection({});
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql);
        var stubExecuteUpdate = sandbox.stub(connection, "executeUpdate").withArgs(sql);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(stubExecuteQuery.called).to.be.ok();
        expect(stubExecuteUpdate.called).to.not.be.ok();
    });

    it("calls execSingle with hdb connection with update statement", function () {
        var sql = "update table set test = '1'";

        var connection = new HDBConnection({});
        var stubExecuteUpdate = sandbox.stub(connection, "executeUpdate").withArgs(sql);
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(stubExecuteUpdate.called).to.be.ok();
        expect(stubExecuteQuery.called).to.not.be.ok();
    });


    it("calls execSingle with hdb connection with delete statement", function () {
        var sql = "delete from table where name = '1''";

        var connection = new HDBConnection({});
        var stubExecuteUpdate = sandbox.stub(connection, "executeUpdate").withArgs(sql);
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(stubExecuteUpdate.called).to.be.ok();
        expect(stubExecuteQuery.called).to.not.be.ok();
    });


    it("calls execSingle with hdb connection with insert statement", function () {
        var sql = "Insert into table (name) values (1)";

        var connection = new HDBConnection({});
        var stubExecuteUpdate = sandbox.stub(connection, "executeUpdate").withArgs(sql);
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(stubExecuteUpdate.called).to.be.ok();
        expect(stubExecuteQuery.called).to.not.be.ok();
    });


    it("calls execSingle with hdb connection with update statement with subselect", function () {
        var sql = "UPDATE table1 SET table1field = (SELECT MAX(table2.table2field) FROM table2 WHERE table1.table1field = table2.table2field)";

        var connection = new HDBConnection({});
        var stubExecuteUpdate = sandbox.stub(connection, "executeUpdate").withArgs(sql);
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(stubExecuteUpdate.called).to.be.ok();
        expect(stubExecuteQuery.called).to.not.be.ok();
    });



    it("calls execSingle with hdb connection with insert statement with subselect", function () {
        var sql = "insert into table (group, id, price)\n" +
            "select \n" +
            "    8, articleId, 1.20\n" +
            "from article where name like 'TEST%';";

        var connection = new HDBConnection({});
        var stubExecuteUpdate = sandbox.stub(connection, "executeUpdate").withArgs(sql);
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql);

        var executor = new SQLExecutor(connection);
        executor.execSingle(sql);

        expect(stubExecuteUpdate.called).to.be.ok();
        expect(stubExecuteQuery.called).to.not.be.ok();
    });
    
    
    it("calls execQuery with db connection correctly", function () {
        var sql = "select * from (*)";

        var rsData = {
            sync: {
                fetch: function () {
                    return [{
                        "hugo": "some string" // should be VARBINARY
                    }];
                }
            },
            metadata: [
                {
                    columnDisplayName: "hugo",
                    dataType: 51 // TEXT
                }
            ]
        };
        var rs = new ResultSet(rsData);

        // workaround to create statement mock since original constructor requires
        // additional info
        var statement = DBPreparedStatement.prototype;
        var mockStatement = sandbox.mock(statement);
        mockStatement.expects("execute").never();
        mockStatement.expects("executeQuery").returns(rs);
        mockStatement.expects("close");

        var connection = new DBConnection({});
        var mockConnection = sandbox.mock(connection);
        mockConnection.expects("prepareStatement").withArgs(sql).returns(statement);

        var executor = new SQLExecutor(connection);
        executor.execQuery(sql);

        expect(mockConnection.verify()).to.be.ok();
        expect(mockStatement.verify()).to.be.ok();
    });

    it("calls execQuery with hdb connection correctly", function () {
        var sql = "select * from (*)";

        var data = [{
            "hugo": "some string" // should be VARBINARY
        }];

        data.metadata = [];
        
        var connection = new HDBConnection({});
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql).returns(data);

        var executor = new SQLExecutor(connection);
        executor.execQuery(sql);

        expect(stubExecuteQuery.called).to.be.ok();
    });

    it("calls callProcedure with db connection correctly", function () {
        var sql = "select * from (*)";

        var rsData = {
            sync: {
                fetch: function () {
                    return [{
                        "hugo": "some string" // should be VARBINARY
                    }];
                }
            },
            metadata: [
                {
                    columnDisplayName: "hugo",
                    dataType: 51 // TEXT
                }
            ]
        };
        var rs = new ResultSet(rsData);

        // workaround to create statement mock since original constructor requires
        // additional info
        var statement = DBPreparedStatement.prototype;
        var mockStatement = sandbox.mock(statement);
        mockStatement.expects("execute");
        mockStatement.expects("close");
        mockStatement.expects("getResultSet").returns(rs);
        mockStatement.expects("getMoreResults").returns(false);

        var connection = new DBConnection({});
        var mockConnection = sandbox.mock(connection);
        mockConnection.expects("prepareCall").withArgs(sql).returns(statement);

        var executor = new SQLExecutor(connection);
        var result = executor.callProcedure(sql);

        expect(result).to.be.an("array");
        expect(result["0"].columns.hugo.rows["0"]).to.be("some string");
        expect(mockConnection.verify()).to.be.ok();
        expect(mockStatement.verify()).to.be.ok();
    });

    it("calls callProcedure with hdb connection correctly", function () {
        var qualName = "proc name";

        var rsData = {
            sync: {
                fetch: function () {
                    return [{
                        "hugo": "some string" // should be VARBINARY
                    }];
                }
            },
            metadata: [
                {
                    columnDisplayName: "hugo",
                    dataType: 51 // TEXT
                }
            ]
        };
        var rs = new ResultSet(rsData);

        var proc = function (args) {
            return {
                $resultSets: [
                    rs
                ]
            }
        };

        var connection = new HDBConnection({});
        var mockConnection = sandbox.mock(connection);
        mockConnection.expects("loadProcedure").withArgs(qualName).returns(proc);

        var executor = new SQLExecutor(connection);
        var result = executor.callProcedure(qualName);

        expect(result).to.be.an("array");
        expect(result["0"].columns.hugo.rows["0"]).to.be("some string");
        expect(mockConnection.verify()).to.be.ok();
    });
    
    
    
    
    it('calls execQuery for hdb resultSet - check for correct metadata', function () {
        var sql = 'select * from "xsjs_test.db::test_table"';

        var data = [
            {
                "ID": 1,
                "TXT": "Bla"
            },
            {
                "ID": 2,
                "TXT": "Bla"
            },
            {
                "ID": 3,
                "TXT": "Bla"
            },
            {
                "ID": 4,
                "TXT": "Bla"
            }
        ];

        data.metadata = [
            {
                "mode": 2,
                "dataType": 3,
                "fraction": 0,
                "length": 10,
                "tableName": "xsjs_test.db::test_table",
                "columnName": "ID",
                "columnDisplayName": "ID"
            },
            {
                "mode": 2,
                "dataType": 11,
                "fraction": 0,
                "length": 200,
                "tableName": "xsjs_test.db::test_table",
                "columnName": "TXT",
                "columnDisplayName": "TXT"
            }
        ];
        
        
        var expectedResult = {
            "columns": {
                "ID": {
                    "colIndex": undefined,
                    "metaData": {
                        "ColumnLabel": "ID",
                            "ColumnType": 3,
                            "ColumnTypeName": "INT"
                    },
                    "getter": null,
                        "rows": [
                        1,
                        2,
                        3,
                        4
                    ]
                },
                "TXT": {
                    "colIndex": undefined,
                    "metaData": {
                        "ColumnLabel": "TXT",
                            "ColumnType": 11,
                            "ColumnTypeName": "NVARCHAR"
                    },
                    "getter": null,
                        "rows": [
                        "Bla",
                        "Bla",
                        "Bla",
                        "Bla"
                    ]
                    }
                }
        };
        

        var connection = new HDBConnection({});
        var stubExecuteQuery = sandbox.stub(connection, "executeQuery").withArgs(sql).returns(data);

        var executor = new SQLExecutor(connection);
        var result = executor.execQuery(sql);

        expect(stubExecuteQuery.called).to.be.ok();
        
        assert.deepEqual(result.columns.TXT.metaData, expectedResult.columns.TXT.metaData);
        assert.deepEqual(result.columns.ID.metaData, expectedResult.columns.ID.metaData);
        
        assert.deepEqual(result.columns.ID.rows, expectedResult.columns.ID.rows);
        assert.deepEqual(result.columns.TXT.rows, expectedResult.columns.TXT.rows);

        assert.deepEqual(result.columns.ID.getter, expectedResult.columns.ID.getter);
        assert.deepEqual(result.columns.TXT.getter, expectedResult.columns.TXT.getter);

        assert.deepEqual(result.columns.ID.colIndex, expectedResult.columns.ID.colIndex);
        assert.deepEqual(result.columns.TXT.colIndex, expectedResult.columns.TXT.colIndex);
    });



    it('calls execQuery for db resultSet - check for correct metadata', function () {
        var sql = 'select * from "xsjs_test.db::test_table"';

        var i = -1;
        
        var data = {
            next: function () {                
                if(i<3) {
                    i++;
                    return true;
                } else return false;
            },
            getInteger: function () {
                        return actualData[i].ID;
                    },
            getNString: function () {
                        return actualData[i].TXT;
                    }
                            
              
        };
            
            
            
        var actualData = [
            {
                "ID": 1,
                "TXT": "Bla"
            },
            {
                "ID": 2,
                "TXT": "Bla"
            },
            {
                "ID": 3,
                "TXT": "Bla"
            },
            {
                "ID": 4,
                "TXT": "Bla"
            }
        ];
        
        
        data.getMetaData = function() {
            return {
                "_columns": [
                    {
                        "mode"             : 2,
                        "dataType"         : 3,
                        "fraction"         : 0,
                        "length"           : 10,
                        "tableName"        : "xsjs_test.db::test_table",
                        "columnName"       : "ID",
                        "columnDisplayName": "ID"
                    },
                    {
                        "mode"             : 2,
                        "dataType"         : 11,
                        "fraction"         : 0,
                        "length"           : 200,
                        "tableName"        : "xsjs_test.db::test_table",
                        "columnName"       : "TXT",
                        "columnDisplayName": "TXT"
                    }
                ],
                getColumnCount: function () {
                    return 2;
                }
            };
        };


        var expectedResult = {
            "columns": {
                "ID": {
                    "metaData": {
                        "ColumnType": 3,
                        "ColumnTypeName": "INT",
                        "ColumnLabel": "ID",
                        "TableName": "xsjs_test.db::test_table",
                        "Precision": 10,
                        "ColumnDisplaySize": 10,
                        "Scale": 0
                    },
                    "rows": [
                        1,
                        2,
                        3,
                        4
                    ]
                },
                "TXT": {
                    "metaData": {
                        "ColumnType": 11,
                        "ColumnTypeName": "NVARCHAR",
                        "ColumnLabel": "TXT",
                        "TableName": "xsjs_test.db::test_table",
                        "Precision": 200,
                        "ColumnDisplaySize": 200,
                        "Scale": 0
                    },
                    "rows": [
                        "Bla",
                        "Bla",
                        "Bla",
                        "Bla"
                    ]
                }
            }
        };


        var statement = DBPreparedStatement.prototype;
        var mockStatement = sandbox.mock(statement);
        mockStatement.expects("execute");
        mockStatement.expects("close");
        mockStatement.expects("executeQuery").withArgs().returns(data);

        var connection = new DBConnection({});
        var mockConnection = sandbox.mock(connection);
        mockConnection.expects("prepareStatement").withArgs(sql).returns(statement);


        var executor = new SQLExecutor(connection);
        var result = executor.execQuery(sql);

        

        assert.deepEqual(result.columns.TXT.metaData, expectedResult.columns.TXT.metaData);
        assert.deepEqual(result.columns.ID.metaData, expectedResult.columns.ID.metaData);

        assert.deepEqual(result.columns.ID.rows, expectedResult.columns.ID.rows);
        assert.deepEqual(result.columns.TXT.rows, expectedResult.columns.TXT.rows);

    });
    
});