function SqlScriptDependencySubstitutor() {

	var formatter = new ($.import("sap.hana.testtools.mockstar", "stringFormatter").StringFormatter)();
	var quote = "";
	// var lineBreakCharacters = [ "\r", "\n", "\u0085", "\u2028", "\u2029" ];
	var optionalPlaceholder = "(?:\\s*\\(\\s*PLACEHOLDER[^\\)]*\\))?";
	var noDotFollowing = "(?!\\s*\\.)";
	var defaultSchemaCallback = "";

	function optionallyQuoteRegExp(str) {
		var backrefQuote = "(?:" + quote + ")";
		var quotedStr = backrefQuote + str + backrefQuote;
		quotedStr = "(?:" + quotedStr + "|" + str + ")";
		return quotedStr;
	}
	function escapeRegExp(str) {
		return str.replace(/[\\\^$()\[\]{}|.?*+\-]/g, "\\$&");
	}

	this.setQuote = function(quoteString) {
		quote = quoteString;
	};

	this.setDefaultSchemaCallback = function(callback) {
		defaultSchemaCallback = callback;
	};

	// Initialize
	this.setQuote("&quot;");
	this.setDefaultSchemaCallback(function(hanaObject) {
		var schema = "";
		var matches = hanaObject.cdata.match(/<defaultSchema schemaName="([^"]*)"/);
		if (matches) {
			schema = matches[1];
		}
		return schema;
	});

	function regexpNoTwoCharSequence(char1, char2, allowLineBreak) {
		// Don't add '+' after '[...]'! Seems to be a bug in RegExp
		function not(chars) {
			return "[^" + chars + (allowLineBreak ? "" : /*lineBreakCharacters.join("")*/"\\r\\n") + "]";
		}
		return "(?:" + not(char1) + "|" + char1 + "(?!" + char2 + "))*?";
	}
	var noInlineComment = regexpNoTwoCharSequence("\\-", "\\-", false);
	var beginBlockComment = "\\/\\*";
	var blockComment = regexpNoTwoCharSequence("\\*", "\\/", true);
	var endBlockComment = "\\*\\/";
	var findBlockComments = new RegExp("^(" + noInlineComment + ")" + beginBlockComment + blockComment + endBlockComment, "mg");
	var findLineComments = /--.*$/mg;

	function removeLineComments(hanaObject) {
		hanaObject.cdata = hanaObject.cdata.replace(findLineComments, "");
	}
	function removeBlockComments(hanaObject) {
		hanaObject.cdata = hanaObject.cdata.replace(findBlockComments, "$1");
	}
	function removeComments(hanaObject) {
		// regular expression is unable to handle more than one block comment in one line, so execute repeatedly
		var previousLength = 0;
		while (hanaObject.cdata.length !== previousLength) {
			previousLength = hanaObject.cdata.length;
			removeBlockComments(hanaObject);
		}

		removeLineComments(hanaObject);
	}

	function cleanupNewlines(hanaObject) {
		hanaObject.cdata = hanaObject.cdata.replace(/&#xD;(\r|\n)/g, "$1");
	}

	function getRegExp(pattern, replacements) {
		return new RegExp(formatter.format(pattern, replacements), "gi");
	}
	
	function makeAliasReplacer(operator, substituteTableName) {
		return function(match, optionalBracket, oldTableName, offset, cdata) {
			var replacement = operator + " " + optionalBracket + substituteTableName;

			var tail = cdata.substr(offset + match.length);
			if (/^\s*$/.test(tail) || 
					/^\s*[,;\)]/.test(tail) || 
					/^\s+(?:WHERE|SET|JOIN|INNER|OUTER|LEFT|RIGHT|FULL|CROSS|UNION|INTERSECT|EXCEPT|FROM|INTO|GROUP|HAVING|ORDER|LIMIT|AS\s+OF)\b/i.test(tail)) {
				return replacement + " AS " + oldTableName; // exclude all key words that are allowed after table name => no alias
			}

			return replacement; // alias given
		};
	}
	
	function generateSubstitute(operator, substituteTableName, useAlias) {
		if (useAlias) {
			return makeAliasReplacer(operator, substituteTableName);
		}
		return operator + " $1" + substituteTableName;
	}
	
	function substituteSQLStatements(hanaObject, substitutionRule, operator, useAlias, suffix) {
		// TODO: optimization: don't use alias if substitutionRule.originalObjectName === substitutionRule.substituteObjectName?

		var operatorBoundary = "";
		if (/^[A-Z]/.test(operator)) {
			operatorBoundary = "\\b";
		}

		var originalTagReplacements = [ operator, substitutionRule.originalSchema, substitutionRule.originalObjectName ].map(escapeRegExp);
		// TODO: order of placeholder and alias (relevant?)
		var originalTagRegex = getRegExp(operatorBoundary + "{0}\\s*((?:\\(\\s*)*)" 
				+ optionallyQuoteRegExp("\\b{1}") + "\\s*\\.\\s*(" + optionallyQuoteRegExp("{2}\\b") + ")" 
				+ (suffix || ""), originalTagReplacements);

		var substituteTableNamePattern = "{0}{1}{0}.{0}{2}{0}";
		var substituteTagReplacements = [ quote, substitutionRule.substituteSchema, substitutionRule.substituteObjectName ];
		var substituteTableName = formatter.format(substituteTableNamePattern, substituteTagReplacements);

		var substitute = generateSubstitute(operator, substituteTableName, useAlias);
		hanaObject.cdata = hanaObject.cdata.replace(originalTagRegex, substitute);

		if (substitutionRule.originalSchema === substitutionRule.defaultSchema) {
			originalTagRegex = getRegExp(operatorBoundary + "{0}\\s*((?:\\(\\s*)*)(" + optionallyQuoteRegExp("\\b{2}\\b") + ")" + (suffix || ""), originalTagReplacements);
			hanaObject.cdata = hanaObject.cdata.replace(originalTagRegex, substitute);
		}
	}	
	
	function substituteFromStatements(hanaObject, substitutionRule, suffix) {
		substituteSQLStatements(hanaObject, substitutionRule, "FROM", true, suffix || "");
	}

	function substituteProcedureCalls(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "CALL", false);
	}

	function substituteJoinStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "JOIN", true);
		substituteSQLStatements(hanaObject, substitutionRule, ",", true, noDotFollowing);
	}

	function substituteSetOperatorStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "UNION", true);
		substituteSQLStatements(hanaObject, substitutionRule, "UNION ALL", true);
		substituteSQLStatements(hanaObject, substitutionRule, "UNION DISTINCT", true);
		substituteSQLStatements(hanaObject, substitutionRule, "INTERSECT", true);
		substituteSQLStatements(hanaObject, substitutionRule, "INTERSECT DISTINCT", true);
		substituteSQLStatements(hanaObject, substitutionRule, "EXCEPT", true);
		substituteSQLStatements(hanaObject, substitutionRule, "EXCEPT DISTINCT", true);
		substituteSQLStatements(hanaObject, substitutionRule, "INTO", false);
	}

	function substituteUpdateStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "FROM", true, optionalPlaceholder);
		substituteSQLStatements(hanaObject, substitutionRule, "UPDATE", true, optionalPlaceholder);
	}

	function substituteInsertStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "INSERT INTO", false, optionalPlaceholder);
	}

	function substituteUpsertStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "UPSERT", false, optionalPlaceholder); // TODO: alias not supported, do something else
	}

	function substituteReplaceStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "REPLACE", false, optionalPlaceholder); // TODO: alias not supported, do something else
	}

	function substituteDeleteStatements(hanaObject, substitutionRule) {
		substituteSQLStatements(hanaObject, substitutionRule, "DELETE FROM", true, optionalPlaceholder);
		substituteSQLStatements(hanaObject, substitutionRule, "DELETE HISTORY FROM", true, optionalPlaceholder);
	}

	function substituteObjectInFunction(hanaObject, substitutionRule, functionType, functionTypeTarget) {
		if (!functionTypeTarget) {
			functionTypeTarget = functionType;
		}

		var operatorBoundary = "";
		if (/^[A-Z]/.test(functionType)) {
			operatorBoundary = "\\b";
		}

		var originalTagReplacements = [ functionType, substitutionRule.originalSchema, substitutionRule.originalObjectName ].map(escapeRegExp);
		var originalTagRegex = getRegExp(operatorBoundary + "{0}\\s*\\(\\s*" + optionallyQuoteRegExp("{1}") + "\\s*\\.\\s*" + optionallyQuoteRegExp("{2}\\b"), originalTagReplacements);

		var substituteTagPattern = "{0}({1}{2}{1}.{1}{3}{1}";
		var substituteTagReplacements = [ functionTypeTarget, quote, substitutionRule.substituteSchema, substitutionRule.substituteObjectName ];
		var substituteTag = formatter.format(substituteTagPattern, substituteTagReplacements);

		hanaObject.cdata = hanaObject.cdata.replace(originalTagRegex, substituteTag);

		if (substitutionRule.originalSchema === substitutionRule.defaultSchema) {
			originalTagRegex = getRegExp(operatorBoundary + "{0}\\s*\\(\\s*" + optionallyQuoteRegExp("{2}\\b"), originalTagReplacements);
			hanaObject.cdata = hanaObject.cdata.replace(originalTagRegex, substituteTag);
		}
	}
	
	function trimSchemaFromFullyQualifiedColumns(hanaObject, substitutionRule) {
		var originalTagReplacements = [ substitutionRule.originalSchema, substitutionRule.originalObjectName ].map(escapeRegExp);
		var originalTagRegex = getRegExp(optionallyQuoteRegExp("\\b{0}") + "\\s*\\.\\s*(" + optionallyQuoteRegExp("{1}") + "\\s*\\.)", originalTagReplacements);
		hanaObject.cdata = hanaObject.cdata.replace(originalTagRegex, "$1");
	}
	
	function substituteViewRefWithViewRef(hanaObject, defaultSchema, dependency) {
		var substitutionRule = {
			defaultSchema : defaultSchema,
			originalSchema : dependency.oldLocation.getSchema(),
			originalObjectName : dependency.oldLocation.getName(),
			substituteSchema : dependency.getSchema(),
			substituteObjectName : dependency.getName()
		};

		substituteFromStatements(hanaObject, substitutionRule, false);
		substituteJoinStatements(hanaObject, substitutionRule);
		substituteObjectInFunction(hanaObject, substitutionRule, "APPLY_FILTER");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_JOIN_VIEW");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_CALC_VIEW");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_OLAP_VIEW");

		trimSchemaFromFullyQualifiedColumns(hanaObject, substitutionRule);
	}

	function substituteViewRefWithTableRef(hanaObject, defaultSchema, dependency) {

		var substitutionRule = {
			defaultSchema : defaultSchema,
			originalSchema : dependency.oldLocation.getSchema(),
			originalObjectName : dependency.oldLocation.getName(),
			substituteSchema : dependency.getSchema(),
			substituteObjectName : dependency.getName()
		};

		substituteFromStatements(hanaObject, substitutionRule, optionalPlaceholder);
		substituteJoinStatements(hanaObject, substitutionRule);
		substituteObjectInFunction(hanaObject, substitutionRule, "APPLY_FILTER");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_JOIN_VIEW", "CE_COLUMN_TABLE");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_CALC_VIEW", "CE_COLUMN_TABLE");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_OLAP_VIEW", "CE_COLUMN_TABLE");

		trimSchemaFromFullyQualifiedColumns(hanaObject, substitutionRule);
	}

	function substituteProcedureRefWithProcedureRef(hanaObject, defaultSchema, dependency) {

		var substitutionRule = {
			defaultSchema : defaultSchema,
			originalSchema : dependency.oldLocation.getSchema(),
			originalObjectName : dependency.oldLocation.getName(),
			substituteSchema : dependency.getSchema(),
			substituteObjectName : dependency.getName()
		};

		substituteProcedureCalls(hanaObject, substitutionRule);
	}

	function substituteTableRefWithTableRef(hanaObject, defaultSchema, dependency) {

		var substitutionRule = {
			defaultSchema : defaultSchema,
			originalSchema : dependency.oldLocation.getSchema(),
			originalObjectName : dependency.oldLocation.getName(),
			substituteSchema : dependency.getSchema(),
			substituteObjectName : dependency.getName()
		};

		substituteFromStatements(hanaObject, substitutionRule, optionalPlaceholder);
		substituteJoinStatements(hanaObject, substitutionRule);
		substituteSetOperatorStatements(hanaObject, substitutionRule);
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_COLUMN_TABLE");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_JOIN");
		substituteObjectInFunction(hanaObject, substitutionRule, "CE_LEFT_OUTER_JOIN");
		substituteObjectInFunction(hanaObject, substitutionRule, "APPLY_FILTER");

		substituteUpdateStatements(hanaObject, substitutionRule);
		substituteInsertStatements(hanaObject, substitutionRule);
		substituteUpsertStatements(hanaObject, substitutionRule);
		substituteReplaceStatements(hanaObject, substitutionRule);
		substituteDeleteStatements(hanaObject, substitutionRule);

		trimSchemaFromFullyQualifiedColumns(hanaObject, substitutionRule);
	}
	
	this.execute = function(hanaObject) {
		removeComments(hanaObject);
		cleanupNewlines(hanaObject);
		var defaultSchema = defaultSchemaCallback(hanaObject);

		hanaObject.getObjectDependencies().forEach(function(dependency) {
			if (dependency.wasTable()) {
				substituteTableRefWithTableRef(hanaObject, defaultSchema, dependency);
			} else if (dependency.wasView()) {
				if (dependency.isView()) {
					substituteViewRefWithViewRef(hanaObject, defaultSchema, dependency);
				} else {
					substituteViewRefWithTableRef(hanaObject, defaultSchema, dependency);
				}
			} else if (dependency.wasProcedure()) {
				substituteProcedureRefWithProcedureRef(hanaObject, defaultSchema, dependency);
			}
		});
	};
}
