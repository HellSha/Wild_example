var vm = require('vm')
var mUtil = require('util')
var _ = require('lodash')
var fs = require('fs')
var path = require('path')

var Instrumenter = require('istanbul/lib/instrumenter')
var Collector = require('istanbul/lib/collector')
var Report = require('istanbul/lib/report')
var Store = require('istanbul/lib/store')
var Reporter = require('istanbul/lib/reporter')
var Configuration = require('istanbul/lib/config')

var mMkdirp = require('./util/mkdirp.js')
var Fileset = require('./fileset.js')

var originalCreateScript = vm.createScript
var originalScriptConstructor = vm.Script

/*
var fnMatch = function(file){
    var match = file.match('.*xsjslib')
    return !!match
}
*/

// function mkdirIfMissingSync(aPath){
//     for(var j=1;j<=aPath.length;j++){
//         var path = aPath.slice(0,j).join('/')
//         if(fs.existsSync(path)){
//             continue
//         }else{
//             fs.mkdirSync(path)
//         }
//     }//for
// }


module.exports = function coverage(options){

    var XsScriptStore = function(opts){
        Store.call(this,opts)
    }
    XsScriptStore.TYPE = 'xsscript'
    mUtil.inherits(XsScriptStore, Store)

    var mixIn = {
        keys: function () {
            return []
        },
        get: function (key) {
            var fscript = key
            if(!fs.existsSync(fscript)){
                for(var idir in options.rootDirs){
                    var dir = options.rootDirs[idir]
                    var _f = path.join(dir, key)
                    if(fs.existsSync(_f)){
                        fscript = _f
                        break
                    }
                }//for
            }
            return fs.readFileSync(fscript, 'utf8')
        },
        hasKey: function (key) {
            if(fs.existsSync(key)){
                return true
            }
            for(var idir in options.rootDirs){
                var dir = options.rootDirs[idir]
                var fscript = path.join(dir, key)
                try{
                    var stats = fs.statSync(fscript)
                    if(stats.isFile()){
                        return true
                    }
                }catch(x){
                }
            }
            return false
        },
        set: function (key) {
            if (!this.hasKey(key)) {
                throw new Error('Attempt to set contents for non-existent file [' + key + '] on a fslookup store');
            }
            return key;
        }
    };
    Store.mix(XsScriptStore, mixIn);


    /*
    function covTransform(matcher, transformer, verbose) {

        return function (code, filename) {
            var shouldHook = typeof filename === 'string' && matcher(path.resolve(filename)),
                transformed,
                changed = false;

            if (shouldHook) {
                if (verbose) {
                    console.error('Module load hook: transform [' + filename + ']');
                }
                try {
                    transformed = transformer(code, filename);
                    changed = true;
                } catch (ex) {
                    console.error('Transformation error; return original code');
                    console.error(ex);
                    transformed = code;
                }
            } else {
                transformed = code;
            }
            return { code: transformed, changed: changed };
        }
    }*/


    function Coverage(){

        this._mixIn = mixIn;

        var covOptions = options.coverage
        if(!covOptions || typeof covOptions!=='object'){
            covOptions = {}
        }
        //covOptions.reporting = covOptions.reporting || {}

        var defaultOptions = {
            verbose: false,
            reporting: {
                reports: ['html']
            },
            instrumentation: {
                includes : ['**/*.xsjslib'],
                excludes : []
            }
        }

        covOptions = _.defaultsDeep(covOptions, defaultOptions)

        console.log('Effective coverage options', JSON.stringify(covOptions,null,2))

        if(typeof covOptions.reporting.reports==='string'){
            covOptions.reporting.reports = [covOptions.reporting.reports]
        }

        var config = Configuration.loadFile(covOptions.config, covOptions)
        var reportingOptions = config.reporting.config = config.reporting.config || {}
        var formatConfig = reportingOptions['report-config'] = reportingOptions['report-config'] || {}

        _.defaults(formatConfig, {
            html : {},
            lcov : {},
            lcovonly : {},
            clover :{},
            json : {},
            cobertura : {},
            text : {}
        })

        var xsSourceStore = new XsScriptStore()
        formatConfig.html.sourceStore = xsSourceStore
        formatConfig.lcov.sourceStore = xsSourceStore
        formatConfig.lcovonly.sourceStore = xsSourceStore
        formatConfig.clover.sourceStore = xsSourceStore
        formatConfig.json.sourceStore = xsSourceStore
        formatConfig.cobertura.sourceStore = xsSourceStore
        formatConfig.text.sourceStore = xsSourceStore

        config.reporting.config['report-config'] = formatConfig

        Report.loadAll()
        Store.loadAll()

        var coverageVar = '$$cov_' + new Date().getTime() + '$$'
        var instrumenter = new Instrumenter({ coverageVariable: coverageVar , preserveComments: true})
        var transformer = instrumenter.instrumentSync.bind(instrumenter)

        var fileset = new Fileset(covOptions.instrumentation.includes, covOptions.instrumentation.excludes)

        function transformCode(code,file){
            var transformed
            try {
                transformed = transformer(code, file)
            } catch (ex) {
                console.error('Transformation error; return original code')
                console.error(ex)
                transformed = code
            }
            return transformed
        }

        vm.createScript = function (code, file) {
            var transformed = code
            if(fileset.test(file)){
                //file = file.slice(1)
                transformed = transformCode(code,file)
            }
            return originalCreateScript(transformed, file)
        }

        vm.Script = function(code,file){
            var transformed = code
            if(fileset.test(file)){
                transformed = transformCode(code,file)
            }
            return new originalScriptConstructor(transformed,file)
        }

        this.coverageObject = {}
        this.coverageVar = coverageVar
        this.config = config
    }

    /**
    * convert keys and path uris to project root relative paths
    */
    Coverage.prototype._makeRelative = function _makeRelative(oCoverageObject, sBaseFolder) {
      var oNewCovObject = {};
      Object.keys(oCoverageObject).forEach(function(key) {
        var val = oCoverageObject[key];

        var sNewKey = path.normalize(path.relative(sBaseFolder, key));
        val.path = path.normalize(path.relative(sBaseFolder, val.path));

        oNewCovObject[sNewKey] = val;
      });

      return oNewCovObject;
    }

    Coverage.prototype.finalize = function finalize(fnCallback){
        var reportingDir;
        var reportingFileName;
        if(options.coverage) {
            if(options.coverage.dir) {
                reportingDir = options.coverage.dir;
            } else {
                reportingDir = options.test.reportdir || '.'
                reportingDir = path.join(reportingDir,'coverage')
            }

            var fileExt = options.coverage.reporting.reports[0] || "json";

            reportingFileName = options.coverage.filename || "coverage";
            reportingFileName = reportingFileName + "." + fileExt;
        }

        this.coverageObject = this._makeRelative(this.coverageObject, process.cwd());

        reportingDir = path.resolve(reportingDir)
        mMkdirp.mkdirpSync(reportingDir)
        //mkdirIfMissingSync(reportingDir.split('/'))
        var fCov = path.resolve(reportingDir, reportingFileName)
        fs.writeFileSync(fCov, JSON.stringify(this.coverageObject), 'utf8')
        var collector = new Collector()
        collector.add(this.coverageObject)

        var reporter = new Reporter( this.config, reportingDir)
        reporter.addAll(this.config.reporting.reports())
        reporter.write(collector, true, function(err){
            if(fnCallback) fnCallback(err)
        })
    }

    return Coverage
}
