/*global Uint8Array, ArrayBuffer*/
/**
 * @module tableUtils
 */

var SqlExecutor = require('./sqlExecutor.js')
var tableDataSet = require('./tableDataSet.js')
var constants = require('@sap/hdbext').constants
var useSchema = false

var TableUtils = null

    //var SqlExecutor = $.import("sap.hana.testtools.unit.util", "sqlExecutor").SqlExecutor;
    //var tableDataSet = $.import("sap.hana.testtools.unit.util", "tableDataSet");
    //var Repository = $.import("sap.hana.testtools.unit.util.internal", "repository").Repository;
    //var csvParser = $.import("sap.hana.testtools.unit.util.internal", "csvParser");
    //var userSchema = $.session.getUsername().toUpperCase();

    /**
     * Creates an TableUtils object.
     *
     * @example
     *
     * <pre>
     * var TableUtils = $.import(&quot;sap.hana.testtools.unit.util&quot;, &quot;tableUtils&quot;).TableUtils;
     * var connection = $.db.getConnection();
     * var tableUtils = new TableUtils(connection);
     * </pre>
     *
     * @class TableUtils provides convenience functions for test table handling
     * @constructor
     * @param {$.db.Connection}
     *            connection database connection
     */
    TableUtils = function(connection) {
        this.connection = connection;
        this.sqlExecutor = new SqlExecutor(connection);
        //samir this.repository = new Repository(connection);
    }

    function getFullTableName(tableSchema, tableName) {
        var tableNameNoQuotes = tableName.replace('"', "", "g");
        if(useSchema){
            return '"' + tableSchema + '"."' + tableNameNoQuotes + '"';
        }else{
            return '"' + tableNameNoQuotes + '"';
        }
    }

    function addPrimaryKeyToTable(tableName, keys) {
        var primaryKeys = keys.join('","');
        var alterTableString = "alter table " + tableName + ' add primary key ("' + primaryKeys + '")';
        this.sqlExecutor.execSingle(alterTableString);
    }

    function dropTestTable(testTableName) {
        this.sqlExecutor.execSingleIgnoreFailing("drop table " + getFullTableName(userSchema, testTableName));
    }

    function getCreateTableStatmentLikeOrigin(testTable, originTable) {
        //samir
        //return "create column table " + testTable + " like " + originTable + " with no data";
        return "create local temporary table " + testTable + " like " + originTable + " with no data";
    }

    /**
     * Tries to resolve schema mappings. Returns the authoring schema if no suitable schema mapping is found.
     *
     * @param {String}
     *            schemaName name of the authoring schema
     *
     * @returns {String} the physical schema that the authoring schema maps to
     *
     * @memberof!module:tableUtils~TableUtils.prototype
     *
     * @since 1.10.3
     */
    TableUtils.prototype.getPhysicalSchemaName = function(schemaName) {
        //samir return this.repository.getPhysicalSchemaName(schemaName);
        return schemaName
    };

    // TODO: extend (row tables, history tables, parameters, comments,...)
    // TODO: maybe better: "create table blub like blub with no data", then drop keys
    function getCreateTableStatmentFromOriginNoKeys(testTable, originTable) {
        var selectStatement = this.connection.prepareStatement("select top 0 * from " + originTable);
        var resultSet = selectStatement.executeQuery();

        var tableMetadata = resultSet.getMetaData();
        var i = 1;
        var name = "";
        var type = "";
        var precision = "";
        var scale = "";

        var columnDefinitions = [];
        for (i = 1; i < tableMetadata.getColumnCount() + 1; i++) {
            name = '"' + tableMetadata.getColumnName(i) + '"';
            type = tableMetadata.getColumnTypeName(i);
            precision = "";

            if (type !== "INTEGER") {
                precision = tableMetadata.getPrecision(i);
                scale = tableMetadata.getScale(i);
                if (precision) {
                    precision = "(" + precision;
                    if (scale) {
                        precision += "," + scale;
                    }
                    precision += ")";
                }
            }
            columnDefinitions.push(name + " " + type + " " + precision);
        }

        //samir
        //return "create column table " + testTable + "( " + columnDefinitions.join() + " )";
        return "create local temporary table " + testTable + "( " + columnDefinitions.join() + " )";

    }

    function createTestTable(tableSchema, tableName, testTableName, removeKeys) {
        var physicalSchema = this.getPhysicalSchemaName(tableSchema);
        var originTable = getFullTableName(physicalSchema, tableName);
        //samir
        //var testTable = getFullTableName(userSchema, testTableName);
        var testTable = '#' + '"' + testTableName + '"';

        var createTableStmnt = getCreateTableStatmentLikeOrigin(testTable, originTable);
        if (removeKeys) {
            createTableStmnt = getCreateTableStatmentFromOriginNoKeys(testTable, originTable);
        }

        this.sqlExecutor.execSingle(createTableStmnt);
        return testTable;
    }

    function createTestTableFromNonOlapView(viewName, testTableName, viewSchema) {
        var physicalSchema = "_SYS_BIC";
        if (viewSchema) {
            physicalSchema = this.getPhysicalSchemaName(viewSchema);
        }
        var testTable = getFullTableName(userSchema, testTableName);
        var originalView = '"' + physicalSchema + '"."' + viewName + '"';

        this.sqlExecutor.execSingle("create column table " + testTable + " as (select top 0 * from " + originalView + ") with no data");
        return testTable;
    }

    /**
     * Creates a test table as a copy of an existing table into the user schema. If the test table already exists, it will be deleted in advance.
     *
     * @param {String}
     *            tableSchema the schema of the table to be copied (authoring/physical)
     * @param {String}
     *            tableName the name of the table to be copied
     * @param {String}
     *            [newTableName=originName] the name of the target table
     *
     * @returns {String} name of the copied test table including schema name
     *
     * @example
     *
     * <pre>
     * var testTable = tableUtils.copyIntoUserSchema(&quot;SAP_HANA_TEST_DEMO&quot;, &quot;sap.hana.testtools.demo.objects::ORDERS&quot;, &quot;ORDERS&quot;);
     * </pre>
     *
     * @memberof!module:tableUtils~TableUtils.prototype
     */
    TableUtils.prototype.copyIntoUserSchema = function(tableSchema, tableName, newTableName, removeKeys) {
        var testTableName = newTableName !== undefined ? newTableName : tableName;

        //samir
        //dropTestTable.call(this, testTableName);

        return createTestTable.call(this, tableSchema, tableName, testTableName, removeKeys);
    };

    /**
     * Creates a test table like an existing view (non-OLAP) into the user schema. If the test table already exists, it will be deleted in advance.
     *
     * @param {String}
     *            viewName the name of the view to be copied
     * @param {String}
     *            testTableName the name of the target table
     * @param {Array}
     *            [keys] the column names that define the primary key of the target table
     * @param {String}
     *            [viewSchema="_SYS_BIC"] the schema of the view to be copied
     * @returns {String} name of the created test table including schema name
     *
     * @example
     *
     * <pre>
     * var testTable = tableUtils.createTestTableFromView(&quot;sap.hana.testtools.demo.objects.attribute_view_1/AT_PRODUCTS&quot;, &quot;AT_PRODUCTS&quot;, [ &quot;PRODUCT_ID&quot; ]);
     * </pre>
     *
     * @memberof!module:tableUtils~TableUtils.prototype
     */
    TableUtils.prototype.createTestTableFromView = function(viewName, testTableName, keys, viewSchema) {
        dropTestTable.call(this, testTableName);
        var tableName = createTestTableFromNonOlapView.call(this, viewName, testTableName, viewSchema);
        if (keys) {
            addPrimaryKeyToTable.call(this, tableName, keys);
        }
        return tableName;
    };

    /**
     * Creates a temporary table out of an existing table (structure) type. Fills the passed data into the test table.
     *
     * @param {String}
     *            tableAlias the name of the temporary table
     * @param {String}
     *            tableSchema the schema of the existing table type
     * @param {String}
     *            tableName the name of the existing table (structure) type
     * @param {Object|Array|module:tableDataSet~TableDataSet}
     *            [data] one ore multiple data lines
     * @returns {String} name of temporary table
     *
     * @example
     *
     * <pre>
     * var singleEntry = {
	 *     Id : &quot;1&quot;,
	 *     col2 : &quot;A&quot;,
	 *     COL3 : 10.1
	 * };
     * var multEntries = {
	 *     Id : [ &quot;1&quot;, &quot;2&quot; ],
	 *     col2 : [ &quot;A&quot;, &quot;B&quot; ],
	 *     COL3 : [ 10.1, 20.2 ]
	 * };
     *
     * var tmpTableNoData = tableUtils.createTemporaryTable(&quot;TMPTable1&quot;, &quot;SCHEMA&quot;, &quot;package.subpackage::TABLE&quot;);
     * var tmpTableWithSingleEntry = tableUtils.createTemporaryTable(&quot;TMPTable2&quot;, &quot;SCHEMA&quot;, &quot;package.subpackage::TABLE&quot;, singleEntry);
     * var tmpTableWithMultEntries = tableUtils.createTemporaryTable(&quot;TMPTable3&quot;, &quot;SCHEMA&quot;, &quot;package.subpackage::TABLE&quot;, multEntries);
     * </pre>
     */
    TableUtils.prototype.createTemporaryTable = function(tableAlias, tableSchema, tableName, data) {
        //samir

        var physicalSchema = this.getPhysicalSchemaName(tableSchema);
        var temporaryTableName = "#" + tableAlias;
        var originTableType = getFullTableName(physicalSchema, tableName);
        this.sqlExecutor.execSingle("create local temporary table " + temporaryTableName + " like " + originTableType + " with no data");
        this.sqlExecutor.execSingle("truncate table " + temporaryTableName); // workaround

        if (data) {
            this.insertData(temporaryTableName, data);
        }

        return temporaryTableName;

        /*
         var originTableType = getFullTableName(tableSchema, tableName);
         this.sqlExecutor.execSingle("truncate table " + originTableType)
         if (data) {
         this.insertData(originTableType, data)
         }

         return originTableType
         */
    };

    /**
     * Clears the test table that exists in the user schema.
     *
     * @param {String}
     *            testTableName the name of the table in the user schema to be cleared
     *
     * @example
     *
     * <pre>
     * tableUtils.clearTableInUserSchema(&quot;ORDERS&quot;);
     * </pre>
     *
     * @example
     *
     * <pre>
     * var testTable = tableUtils.copyIntoUserSchema(&quot;SAP_HANA_TEST_DEMO&quot;, &quot;ORDERS&quot;);
     * tableUtils.clearTableInUserSchema(testTable);
     * </pre>
     *
     * @memberof!module:tableUtils~TableUtils.prototype
     */
    TableUtils.prototype.clearTableInUserSchema = function(testTableName) {
        //samir
        /*
         var tableNameContainsUserSchema = testTableName.match("^(" + userSchema + '|(")' + userSchema + '("))\\.');
         var fullTableName = tableNameContainsUserSchema ? testTableName : getFullTableName(userSchema, testTableName);
         this.sqlExecutor.execSingle("delete from " + fullTableName);
         */
        //this.sqlExecutor.execSingleIgnoreFailing("delete from " + testTableName)
        this.sqlExecutor.execSingleIgnoreFailing("truncate table " + testTableName)
    };

    function hexToArrayBuffer(value) {
        var size = Math.floor(value.length / 2);
        var buffer = new ArrayBuffer(size);
        var view = new Uint8Array(buffer);
        var i;
        for (i = 0; i < size; ++i) {
            view[i] = parseInt(value.substr(2 * i, 2), 16);
        }
        return buffer;
    }

    function unifyDecimal(value, decSeparator) {
        if (typeof value === "number" || value instanceof Number) {
            return value;
        }
        var int = value;
        var frac = "";
        var sep = value.lastIndexOf(decSeparator);
        if (sep !== -1) {
            int = value.substr(0, sep);
            frac = value.substr(sep + 1);
        }
        value = int.replace(/[,\.]/g, "") + "." + frac.replace(/[,\.]/g, "");
        return value;
    }

    function parseODataDate(dateStr) {
        var parsed = dateStr.match(/^\/Date\((\d+)\)\/$/);
        if (parsed) {
            var time = parseInt(parsed[1], 10);
            var date = new Date(time);
            date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
            return date;
        }else{
            //samir
            var arr = dateStr.match(/(\d)+/g)
            if(arr && arr.length>=6 ){
                var fd = arr[0] + '-' + arr[1] + '-' + arr[2] + 'T' + arr[3] + ':' + arr[4] + ':' + arr[5]
                if(arr[7]){
                    fd +='.'
                    fd += arr[7]
                }
                return fd
            }else if(arr.length==3){
                var fd = arr.join('-')
                fd += 'T00:00:00'
                return fd
            }
        }
        return dateStr;
    }

    function getSetter(metadata, column, decSeparator, nullValue) {
        var type = metadata.getParameterType(column);
        var dbsetter = "setNString";
        var isStringType = true;
        var convert = null;

        switch (type) {
            case constants.types.TINYINT:
            case constants.types.SMALLINT:
            case constants.types.INT:
            case constants.types.INTEGER:
                isStringType = false;
                dbsetter = "setInteger";
                convert = function(value) {
                    return Math.round(parseFloat(value));
                };
                break;
            case constants.types.BIGINT:
                isStringType = false;
                dbsetter = "setBigInt";
                convert = function(value) {
                    return (metadata.isSigned(column) ? ctypes.Int64 : ctypes.UInt64)(value);
                };
                break;
            case constants.types.DECIMAL:
            case constants.types.SMALLDECIMAL:
                isStringType = false;
                dbsetter = "setDecimal";
                convert = function(value) {
                    var unified = unifyDecimal(value, decSeparator);
                    return unified;
                };
                break;
            case constants.types.REAL:
            case constants.types.DOUBLE:
                isStringType = false;
                dbsetter = "setDouble";
                convert = function(value) {
                    var unified = unifyDecimal(value, decSeparator);
                    return parseFloat(unified);
                };
                break;
            case constants.types.DATE:
                isStringType = false;
                dbsetter = "setDate";

                //samir
                convert = function(value){
                    if(value instanceof Date){
                        return value
                    }else if(typeof value === 'string'){
                        var arr = value.match( /(\d)/g )
                        if(arr.length==8){
                            var fd = []
                            fd.push( arr.slice(0,4).join('') )
                            fd.push( arr.slice(4,6).join('') )
                            fd.push( arr.slice(6,8).join('') )
                            fd = fd.join('-')
                            return fd
                        }else{
                            return value
                        }
                    }else{
                        return value
                    }
                }
                break;
            case constants.types.TIME:
                isStringType = false;
                dbsetter = "setTime";
                break;
            case constants.types.TIMESTAMP:
            case constants.types.SECONDDATE:
                isStringType = false;
                dbsetter = "setTimestamp";
                convert = parseODataDate;
                break;
            case constants.types.CHAR:
            case constants.types.VARCHAR:
                break;
            case constants.types.NCHAR:
            case constants.types.NVARCHAR:
                dbsetter = "setNString";
                convert = function(value) {
                    var stringValue = "";
                    return stringValue + value;
                };
                break;
            case constants.types.BINARY:
            case constants.types.VARBINARY:
                dbsetter = "setBString";
                convert = hexToArrayBuffer;
                break;
            case constants.types.CLOB:
                dbsetter = "setClob";
                break;
            case constants.types.NCLOB:
            case constants.types.TEXT:
                dbsetter = "setNClob";
                break;
            case constants.types.BLOB:
                dbsetter = "setBlob";
                convert = hexToArrayBuffer;
                break;
            case constants.types.SHORTTEXT:
            case constants.types.ALPHANUM:
                break;
        }

        return function(col, value) {
            if (typeof value !== "undefined" && value !== null && value !== nullValue && (isStringType || value !== "")) {
                this[dbsetter](col, convert ? convert(value) : value);
            } else {
                this.setNull(col, null);
            }
        };
    }

    function insertTableDataSetIntoTable(fullTableName, data, options) {
        var withColumnNames = options.headers;
        var decSeparator = options.decSeparator;
        var nullValue = options.nullValue;
        var rowCount = data.getRowCount();
        var columns = data.getColumns();

        if (rowCount === 0) {
            return;
        }

        var columnNames = "";
        if (withColumnNames) {
            columnNames = '("' + columns.join('","') + '")';
        }
        var values = "(" + columns.map(function() {
                return "?";
            }).join(",") + ")";

        var insertRecordString = "insert into " + fullTableName + columnNames + " values " + values;
        var insertRecordsStatement = this.connection.prepareStatement(insertRecordString);
        insertRecordsStatement.setBatchSize(rowCount);

        var row, col;
        var setters = [];
        var setter = "";
        var value = "";

        for (col = 0; col < columns.length; col++) {
            setters.push(getSetter(insertRecordsStatement.getParameterMetaData(), col + 1, decSeparator, nullValue));
        }
        for (row = 0; row < rowCount; row++) {
            for (col = 0; col < setters.length; col++) {
                setter = setters[col];
                value = columns[col].getRow(row);
                setter.call(insertRecordsStatement, col + 1, value);
            }
            //if (rowCount > 1) {
            insertRecordsStatement.addBatch();
            //}
        }

        insertRecordsStatement.executeBatch();
        insertRecordsStatement.close();
    }

    /**
     * Fills a test table from a csv-file.
     *
     * @param {String}
     *            fullTableName the table name including the schema name e.g. "SCHEMA"."package.subpackage::tableName"
     * @param {String}
     *            csvPackage the package of the .csv file
     * @param {String}
     *            csvFile the name of the .csv file that contains the data
     * @param {Object}
     *            [csvProperties] defines the properties of the csv file to be imported
     *            <ul>
     *            <li>separator: An override for the separator character. Defaults to a semicolon (;)</li>
     *            <li>headers: Indicates whether the data contains a header line. Defaults to (true)</li>
     *            <li>decSeparator: An override for the decimal separator character. Defaults to a dot(.)</li>
     *            </ul>
     * @example
     *
     * <pre>
     * var csvProperties = {
	 *     separator : &quot;;&quot;,
	 *     headers : false,
	 *     decSeparator : &quot;.&quot;,
	 * };
     * var copiedTableName = tableUtils.copyIntoUserSchema(&quot;SAP_HANA_TEST_DEMO&quot;, &quot;sap.hana.testtools.demo.objects::ORDERS&quot;);
     * tableUtils.fillFromCsvFile(copiedTableName, &quot;sap.hana.testtools.unit.util.test.data&quot;, &quot;Orders.csv&quot;, csvProperties);
     * </pre>
     *
     * @memberof!module:tableUtils~TableUtils.prototype
     */

    /*

     samir - comment CSV functionality


     TableUtils.prototype.fillFromCsvFile = function(fullTableName, csvPackage, csvFile, csvProperties) {
     var defaultProperties = {
     separator : ";",
     headers : true,
     decSeparator : ".",
     castToScalar : false,
     nullValue : "<Null>"
     };
     var mergedCsvProperties = defaultProperties;
     if (csvProperties) {
     mergedCsvProperties = {
     separator : csvProperties.separator || defaultProperties.separator,
     headers : typeof csvProperties.headers !== "undefined" ? csvProperties.headers : defaultProperties.headers,
     decSeparator : csvProperties.decSeparator || defaultProperties.decSeparator,
     castToScalar : defaultProperties.castToScalar,
     nullValue : typeof csvProperties.nullValue !== "undefined" ? csvProperties.nullValue : defaultProperties.nullValue
     };
     }

     var parsedObjects = csvParser.csvToArrays(csvPackage, csvFile, mergedCsvProperties);

     if (!parsedObjects || parsedObjects.length === 0) {
     throw new Error("CSV file " + csvPackage + "::" + csvFile + " contains no data");
     }

     var tableDataSetToBeInserted = tableDataSet.createFromCSVList(parsedObjects, mergedCsvProperties.headers);

     insertTableDataSetIntoTable.call(this, fullTableName, tableDataSetToBeInserted, mergedCsvProperties);
     };
     */



    function isObject(value) {
        return value && typeof value === "object";
    }

    /**
     * Fills the passed data into the test table.
     *
     * @param {String}
     *            fullTableName the table name including the schema name e.g. "SCHEMA"."package.subpackage::TABLE"
     * @param {Object|Array|module:tableDataSet~TableDataSet}
     *            data one ore multiple data lines
     *
     * @example
     *
     * <pre>
     * var singleEntry = {
	 *     Id : &quot;1&quot;,
	 *     col2 : &quot;A&quot;,
	 *     COL3 : 10.1
	 * };
     * var multEntries = {
	 *     Id : [ &quot;1&quot;, &quot;2&quot; ],
	 *     col2 : [ &quot;A&quot;, &quot;B&quot; ],
	 *     COL3 : [ 10.1, 20.2 ]
	 * };
     *
     * var copiedTableName = tableUtils.copyIntoUserSchema(&quot;SCHEMA&quot;, &quot;package.subpackage::TABLE&quot;);
     * tableUtils.insertData(copiedTableName, singleEntry);
     * tableUtils.insertData(copiedTableName, multEntries);
     * </pre>
     *
     * @since 1.9.1
     * @memberof!module:tableUtils~TableUtils.prototype
     */
    TableUtils.prototype.insertData = function(fullTableName, data) {
        var tableDataSetToBeInserted = null;
        if (tableDataSet.isTableDataSet(data)) {
            tableDataSetToBeInserted = data;
        } else if (Array.isArray(data)) {
            tableDataSetToBeInserted = tableDataSet.createFromArray(data);
        } else if (isObject(data)) {
            tableDataSetToBeInserted = tableDataSet.createFromJSON(data);
        }

        var options = {
            headers : true,
            decSeparator : ".",
            nullValue : null
        };
        insertTableDataSetIntoTable.call(this, fullTableName, tableDataSetToBeInserted, options);
    };

    // MockstarFacade.prototype.createTableParameter = function(parameterName, name, p3, p4) {
    // var data;
    // var tableSchema = this.schema;
    // if ((p4 === undefined || p4 === null) && typeof p3 === "object") { // no schema defined
    // data = p3;
    // } else if (typeof p3 === "string" && typeof p4 === "object") { // schema and data defined
    // tableSchema = p3;
    // data = p4;
    // }
    //
    // var parameterTableName = '"' + this.userSchema + '"."#' + parameterName + '"';
    // sqlExecutor.execSingle("create local temporary table " + parameterTableName + ' like "' + tableSchema + '"."' + name + '"');
    //
    // // Insert data
    // processData.call(this, "INSERT INTO", parameterTableName, data);
    //
    // return {
    // name : name,
    // schema : tableSchema,
    // copyName : parameterTableName,
    // isParameter : true
    // };
    // };


module.exports = TableUtils
