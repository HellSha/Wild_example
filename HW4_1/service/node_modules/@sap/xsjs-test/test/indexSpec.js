var expect = require("expect.js");
var fs = require("fs");
var path = require("path");

var rimraf = require("rimraf");

var Index = require("../lib/index.js");
var runtime = require("@sap/xsjs/lib/runtime.js");
var mkdirp = require('../lib/util/mkdirp.js');

var sinon = require("sinon");

var sandbox;
var xsrt = runtime.createRuntime({});

describe("index.js tests", function () {

    var testResultsPath = path.join(__dirname, "___testresults");

    beforeEach(function () {
        sandbox = sinon.sandbox.create();
    });

    afterEach(function () {
        sandbox.restore();
        rimraf.sync(testResultsPath);
    });

    it("loads the correct tests in different packages", function () {
        var index = new Index();

        var testOptions = {
            package: "sap.plc.test",
            pattern: ".*tests"
        };
        var mockXsrt = sandbox.mock(xsrt);
        mockXsrt.expects("createBaseContext");
        mockXsrt.expects("setSandboxHook").never();
        mockXsrt.expects("runXsjslib").never();

        xsrt.xsjslib = {
            "sap.plc_test.testdata/b/fileTest": true,
            "sap.plc_test.test/someTest": true
        };

        index.loadTests(testOptions, xsrt);

        expect(mockXsrt.verify()).to.be.ok();
    });
    
    it("loads the correct tests", function () {
        var index = new Index();

        var testOptions = {
            package: "testPack",
            pattern: ".*[Tt]est"
        };
        var mockXsrt = sandbox.mock(xsrt);
        mockXsrt.expects("createBaseContext");
        mockXsrt.expects("setSandboxHook").once();
        mockXsrt.expects("runXsjslib").withArgs("testPack/b/fileTest", undefined);

        xsrt.xsjslib = {
            "testPack/b/fileTest": true,
            "someOtherPackage/someTest": true
        };

        index.loadTests(testOptions, xsrt);

        expect(mockXsrt.verify()).to.be.ok();
    });

    it("does not load test libs into coverage", function () {
        var index = new Index();

        var testOptions = {
            package: "sap.hana",
            pattern: ".*[Tt]estX"
        };
        var mockXsrt = sandbox.mock(xsrt);
        mockXsrt.expects("createBaseContext");
        mockXsrt.expects("setSandboxHook").once();
        mockXsrt.expects("importLibrary").withArgs("/sap/hana/lib.xsjslib", null, undefined);
        mockXsrt.expects("runXsjslib").never();


        xsrt.xsjslib = {
            "sap.hana.testtools/lib": true,
            "sap.hana/lib": true
        };

        var cov = {};

        index.loadTests(testOptions, xsrt, null, null, cov);

        expect(mockXsrt.verify()).to.be.ok();
    });

    it("runs tests without errors and exits with 0", function () {
        var testOutput = "\"failures\": 0";
        var index = new Index({
            coverage: {
                dir: testResultsPath
            },
            test: {
                reportdir: testResultsPath
            }
        });
        index.runJasmine = function (options, callback) {
            callback(testOutput);
        };

        var mockMkdirp = sandbox.mock(mkdirp);
        mockMkdirp.expects("mkdirpSync");

        var mockFs = sandbox.mock(fs);
        mockFs.expects("writeFileSync").withArgs(path.join(testResultsPath, "report.html"), testOutput).once();

        var mockProcess = sandbox.mock(process);
        mockProcess.expects("exit").withArgs(0).once();

        var spyConsole = sandbox.spy(console, "warn");

        index.runTests();

        expect(mockFs.verify()).to.be.ok();
        expect(mockMkdirp.verify()).to.be.ok();

        expect(spyConsole.called).to.be.ok();
        expect(spyConsole.callCount).to.be(1);
        expect(spyConsole.getCall(0).args[0]).to.contain("[WARNING] No HANA DB configured");
    });

    it("runs tests with errors and exits with number", function () {
        var testOutput = "\"failures\": 8";
        var index = new Index({
            coverage: {
                dir: testResultsPath
            },
            test: {
                reportdir: testResultsPath
            }
        });
        index.runJasmine = function (options, callback) {
            callback(testOutput);
        };

        var mockMkdirp = sandbox.mock(mkdirp);
        mockMkdirp.expects("mkdirpSync");

        var mockFs = sandbox.mock(fs);
        mockFs.expects("writeFileSync").withArgs(path.join(testResultsPath, "report.html"), testOutput).once();

        var mockProcess = sandbox.mock(process);
        mockProcess.expects("exit").withArgs(8).once();

        index.runTests();

        expect(mockFs.verify()).to.be.ok();
        expect(mockMkdirp.verify()).to.be.ok();
    });

    it("runs jasmine tests via callback", function () {
        var index = new Index();
        var mockIndex = sandbox.mock(index);
        mockIndex.expects("loadTests").once();

        var mockRuntime = sandbox.mock(runtime);
        mockRuntime.expects("createRuntime").returns(xsrt);

        var mockXsrt = sandbox.mock(xsrt);
        mockXsrt.expects("createBaseContext").returns({});

        var runOptions = {
            coverage: {
                dir: testResultsPath
            },
            test: {
                reportdir: testResultsPath,
                format: "json"
            }
        };
        var callback = function () {
        };
        index.runJasmine(runOptions, callback);

        expect(mockIndex.verify()).to.be.ok();
        expect(mockRuntime.verify()).to.be.ok();
        expect(mockXsrt.verify()).to.be.ok();
    });
});