function RepositoryFacade(repository) {

	var HanaObjectTypes = $.import("sap.hana.testtools.mockstar", "hanaObjectTypes").HanaObjectTypes;
	var RepositoryPath = $.import("sap.hana.testtools.unit.util.internal", "repositoryPath").RepositoryPath;
	var HanaObjectName = $.import("sap.hana.testtools.mockstar", "hanaObjectName").HanaObjectName;
	var HanaObject = $.import("sap.hana.testtools.mockstar", "hanaObject").HanaObject;
	var HanaObjectType = $.import("sap.hana.testtools.mockstar", "hanaObjectType").HanaObjectType;
	var InternalError = $.import("sap.hana.testtools.unit.util.internal", "error").InternalError;
	var defaultSchema = "_SYS_BIC";
	var supportedDbTypes = [ "calculationview", "analyticview", "attributeview", "hdbcattab", "hdbtable", "hdbprocedure", "procedure", "xsodata", "hdbdd", "hdbview" ];

	function toHanaObjectTypes(sType) {
		var type = "";
		switch (sType) {
		case "calculationview":
			type = HanaObjectTypes.CALCULATION_VIEW;
			break;
		case "analyticview":
			type = HanaObjectTypes.ANALYTIC_VIEW;
			break;
		case "attributeview":
			type = HanaObjectTypes.ATTRIBUTE_VIEW;
			break;
		case "hdbcattab":
		case "hdbtable":
		case "__RT_CATALOG_TABLE__":
		case "__RT_CATALOG_OBJECT__": // TODO only tables?
			type = HanaObjectTypes.TABLE;
			break;
		case "hdbdd":
			type = HanaObjectTypes.HDBDD;
			break;
		case "hdbview":
			type = HanaObjectTypes.HDB_VIEW;
			break;
		case "hdbprocedure":
			type = HanaObjectTypes.HDBPROCEDURE;
			break;
		case "__RT_CATALOG_PROCEDURE__":
		case "procedure":
			type = HanaObjectTypes.PROCEDURE;
			break;
		case "xsodata":
			type = HanaObjectTypes.ODATA;
			break;
		default:
			throw new Error("The repository type " + sType + " is not supported");
		}
		return type; // TODO new HanaObjectType(type);
	}

	// TODO delete or avoid duplicate code!
	this.getModelType = function(modelPath) {
		var parsedModelPath = HanaObjectName.parseName(modelPath);
		var repoType = repository.getRepositoryType(parsedModelPath.packageName, parsedModelPath.objectName, supportedDbTypes);

		return toHanaObjectTypes(repoType);
	};

	function getQualifiedNameOfVirtualTable(referencePackageName, referenceName) {
		var qualifiedName = null;
		var tableName = referencePackageName + "::" + referenceName;
		var tableSchema = repository.getPhysicalSchemaOfVirtualTable(tableName);
		if (tableSchema) {
			qualifiedName = {
				schema : tableSchema,
				name : tableName
			};
		}
		return qualifiedName;
	}

	function getHanaObjectOfHierarchyViewWrappingView(referencePackage, referenceName) {
		var hanaObject = null;
		var wrappingObject = repository.getObjectWhichNameEndsLike(referencePackage, referenceName, "hier%");
		if (wrappingObject) {
			var hanaObjectType = toHanaObjectTypes(wrappingObject.suffix); // attributeview
			var hanaObjectName = referencePackage.concat("/", wrappingObject.name);

			var hierarchyViewId = referenceName.replace(wrappingObject.name + "hier", "");
			var hierarchyViewName = referencePackage.concat("/", wrappingObject.name, "/", "hier", "/", hierarchyViewId);
			hanaObject = new HanaObject("_SYS_BIC", hanaObjectName, hanaObjectType);
			hanaObject.addEntity(hierarchyViewName, HanaObjectTypes.HIERARCHY_VIEW);
		}
		return hanaObject;
	}

	function getNameOfHdbddFile(cdsEntityName) {
		return cdsEntityName.split(".")[0];
	}

	function getPhysicalSchemaOfDTTable(packageName, objectName, objectSuffix) {
		var repositoryPath = RepositoryPath.fromPackageFilenameAndSuffix(packageName, objectName, objectSuffix);
		var cdata = repository.readFile(repositoryPath);
		var match = null;
		if (repositoryPath.getSuffix() === "hdbdd") {
			match = cdata.match(/@\s*Schema\s*:\s*'([^']*)'/);
		} else {
			match = cdata.match(/table.schemaName\s*=\s*"([^"]*)"/);
		}
		return match ? match[1] : "";
	}

	/*
	 * This function should be used rarely! If the repository classifies a non-design-time-table as "__DT_CATALOG_OBJECT__" you might call this in order to get
	 * the schema information. But getPhysicalSchemaOfRTTable throws an InternalError, if it find the table in multiple schemas.
	 */
	function getPhysicalSchemaOfTable(packageName, objectName, objectSuffix) {
		var tableName = packageName + "::" + objectName;
		return getPhysicalSchemaOfDTTable(packageName, objectName, objectSuffix) || repository.getPhysicalSchemaOfRTTable(tableName);
	}

	function getQualifiedNameBySType(packageOrSchema, objectName, sType, getPhysicalSchemaCallback) {
		var qualifiedName = {
			schema : "",
			name : ""
		};

		switch (sType) {
		case "hdbtable":
		case "hdbdd":
		case "hdbcattab":
		case "__RT_CATALOG_TABLE__":
		case "__RT_CATALOG_OBJECT__":// TODO only tables?
			qualifiedName.name = objectName;
			qualifiedName.schema = getPhysicalSchemaCallback(packageOrSchema);
			break;
		case "__RT_CATALOG_VIEW__":
		case "__RT_CATALOG_PROCEDURE__":
			qualifiedName.name = objectName;
			qualifiedName.schema = defaultSchema;
			break;
		case "analyticview":
		case "attributeview":
		case "calculationview":
		case "procedure":
		case "xsodata":
			qualifiedName.name = packageOrSchema + "/" + objectName;
			qualifiedName.schema = defaultSchema;
			break;
		case "hdbprocedure":
			qualifiedName.name = packageOrSchema + "::" + objectName;
			qualifiedName.schema = repository.getPhysicalSchemaOfProcedure(qualifiedName.name);
			break;
		case "hdbview":
			qualifiedName.name = packageOrSchema + "::" + objectName;
			qualifiedName.schema = repository.getPhysicalSchemaOfHDBView(qualifiedName.name);
			break;
		}
		return qualifiedName; // TODO return new HanaObjectName(schema, name) {
	}

	function createHanaObjectFromRepoReferenceData(referencePackageName, referenceName, referenceType, getPhysicalSchemaCallback) {
		var hanaObjectType = "";
		var hanaObjectName = "";
		var repoType;
		var schema = null;

		switch (referenceType) {
		case "__DT_CATALOG_OBJECT__":
			try {
				repoType = repository.getRepositoryType(referencePackageName, referenceName, supportedDbTypes);
				hanaObjectType = toHanaObjectTypes(repoType);
			} catch (e1) {
				if (e1 instanceof InternalError) {
					hanaObjectName = getQualifiedNameOfVirtualTable(referencePackageName, referenceName);
					if (hanaObjectName) {
						hanaObjectType = HanaObjectTypes.VIRTUAL_TABLE;
						break;
					}
					// TODO hierarchyViews
					var hanaObject = getHanaObjectOfHierarchyViewWrappingView(referencePackageName, referenceName);
					return hanaObject;// ignore e.g.referenceName.match("/tabletype/")

				} else {
					throw e1;
				}
			}

			if (new HanaObjectType(hanaObjectType).isTableType()) {
				if (hanaObjectType === HanaObjectTypes.HDBDD) {
					referenceName = getNameOfHdbddFile(referenceName);
				}
				var physicalSchema = getPhysicalSchemaOfTable(referencePackageName, referenceName, repoType);
				hanaObjectName = getQualifiedNameBySType(physicalSchema, referencePackageName + "::" + referenceName, repoType, getPhysicalSchemaCallback);
			} else {
				hanaObjectName = getQualifiedNameBySType(referencePackageName, referenceName, repoType, getPhysicalSchemaCallback);
			}
			break;
		case "__RT_CATALOG_VIEW__":
			hanaObjectName = getQualifiedNameBySType(referencePackageName, referenceName, referenceType, getPhysicalSchemaCallback);
			var parsedModelPath = HanaObjectName.parseName(referenceName);
			repoType = repository.getRepositoryType(parsedModelPath.packageName, parsedModelPath.objectName, supportedDbTypes);
			hanaObjectType = toHanaObjectTypes(repoType);
			break;
		case "__RT_CATALOG_OBJECT__": // TODO correct/test; works for
			// tables only
			hanaObjectName = getQualifiedNameBySType(referencePackageName, referenceName, referenceType, getPhysicalSchemaCallback);
			hanaObjectType = toHanaObjectTypes(referenceType);
			break;
		case "__RT_CATALOG_TABLETYPE__": // should be ignored
		case "__RT_CATALOG_SYNONYM__":
		case "hdbstructure":
		case "hdbruldec":
			return null;
		default:
			hanaObjectName = getQualifiedNameBySType(referencePackageName, referenceName, referenceType, getPhysicalSchemaCallback);
			hanaObjectType = toHanaObjectTypes(referenceType);
			break;
		}
		return new HanaObject(hanaObjectName.schema, hanaObjectName.name, hanaObjectType);
	}

	this.getModel = function(modelPath) {
		var parsedModelPath = HanaObjectName.parseName(modelPath);
		var repoType = repository.getRepositoryType(parsedModelPath.packageName, parsedModelPath.objectName, supportedDbTypes);

		return createHanaObjectFromRepoReferenceData(parsedModelPath.packageName, parsedModelPath.objectName, repoType, this.getPhysicalSchemaName.bind(this));
	};

	function sortHanaObjectsByName(hanaObjects) {
		hanaObjects.sort(function(a, b) {
			var nameA = a.getName().toLowerCase();
			var nameB = b.getName().toLowerCase();
			if (nameA !== nameB) {
				return nameA < nameB ? -1 : 1;
			}

			var schemaA = a.getPhysicalSchema().toLowerCase();
			var schemaB = b.getPhysicalSchema().toLowerCase();
			if (schemaA !== schemaB) {
				return schemaA < schemaB ? -1 : 1;
			}

			return 0;
		});
	}

	function removeHanaObjectDuplicates(hanaObjects) {
		sortHanaObjectsByName(hanaObjects);
		return hanaObjects.filter(function(value, key) {
			return key === 0 || !hanaObjects[key].equals(hanaObjects[key - 1]);
		});
	}

	this.getReferences = function(modelPath) {
		var parsedModelPath = HanaObjectName.parseName(modelPath);
		var repositoryType = repository.getRepositoryType(parsedModelPath.packageName, parsedModelPath.objectName, supportedDbTypes);
		var references = repository.getReferences(RepositoryPath.fromPackageFilenameAndSuffix(parsedModelPath.packageName, parsedModelPath.objectName, repositoryType));

		var getPhysicalSchemaCallback = this.getPhysicalSchemaName.bind(this);
		var hanaObjects = [];
		references.forEach(function(repoReference) {
			var reference = createHanaObjectFromRepoReferenceData(repoReference.package, repoReference.name, repoReference.stype, getPhysicalSchemaCallback);
			if (reference !== null) {
				hanaObjects.push(reference);
			}
		});
		return removeHanaObjectDuplicates(hanaObjects);
	};

	function toRepositoryType(hanaObjectTypesEnum) {
		switch (hanaObjectTypesEnum) {
		case HanaObjectTypes.CALCULATION_VIEW:
			return "calculationview";
		case HanaObjectTypes.ANALYTIC_VIEW:
			return "analyticview";
		case HanaObjectTypes.ATTRIBUTE_VIEW:
			return "attributeview";
		case HanaObjectTypes.TABLE:
			return "hdbcattab";
		case HanaObjectTypes.PROCEDURE:
			return "procedure";
		case HanaObjectTypes.HDBPROCEDURE:
			return "hdbprocedure";
		case HanaObjectTypes.ODATA:
			return "xsodata";
		default:
			throw new Error("The hana object type " + hanaObjectTypesEnum + " is not supported");
		}
	}

	this.readCData = function(modelPath) {
		var parsedModelPath = HanaObjectName.parseName(modelPath);
		var repositoryType = repository.getRepositoryType(parsedModelPath.packageName, parsedModelPath.objectName, supportedDbTypes);

		return repository.readFile(RepositoryPath.fromPackageFilenameAndSuffix(parsedModelPath.packageName, parsedModelPath.objectName, repositoryType));
	};

	this.write = function(hanaObject) {
		var parsedModelPath = hanaObject.location.getParsedName();
		var modelType = toRepositoryType(hanaObject.type.toString());

		repository.writeFile(RepositoryPath.fromPackageFilenameAndSuffix(parsedModelPath.packageName, parsedModelPath.objectName, modelType), hanaObject.cdata);
	};

	this.activate = function(hanaObject) {
		var parsedModelPath = hanaObject.location.getParsedName();
		var modelType = toRepositoryType(hanaObject.type.toString());

		return repository.activateFile(RepositoryPath.fromPackageFilenameAndSuffix(parsedModelPath.packageName, parsedModelPath.objectName, modelType));
	};

	this.revert = function(hanaObject) {
		var parsedModelPath = hanaObject.location.getParsedName();
		var modelType = toRepositoryType(hanaObject.type.toString());

		return repository.revertFile(RepositoryPath.fromPackageFilenameAndSuffix(parsedModelPath.packageName, parsedModelPath.objectName, modelType));
	};

	this.save = function(hanaObject) {
		var parsedModelPath = hanaObject.location.getParsedName();
		var modelType = toRepositoryType(hanaObject.type.toString());

		repository.saveFile(RepositoryPath.fromPackageFilenameAndSuffix(parsedModelPath.packageName, parsedModelPath.objectName, modelType), hanaObject.cdata);
	};

	this.release = function() {
		repository.release();
	};

	this.getPhysicalSchemaName = function(schemaName) {
		return repository.getPhysicalSchemaName(schemaName);
	};

}
